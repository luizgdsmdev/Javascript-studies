<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Quiz with Instant Feedback</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f4f4f9;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        #level-selector {
            margin-bottom: 20px;
            text-align: center;
        }
        #level-selector select {
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        #quiz-container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            overflow-wrap: break-word;
        }
        #question {
            font-size: 18px;
            margin-bottom: 20px;
            color: #333;
        }
        .answer-option {
            margin: 10px 0;
            font-size: 16px;
        }
        .answer-option input[type="radio"] {
            margin-right: 10px;
        }
        .true-false-btn {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .true-btn {
            background-color: #4caf50;
            color: white;
        }
        .false-btn {
            background-color: #f44336;
            color: white;
        }
        .true-btn:hover, .false-btn:hover {
            opacity: 0.9;
        }
        .disabled-btn {
            background-color: #ccc !important;
            cursor: not-allowed;
        }
        #feedback {
            margin-top: 15px;
            font-size: 16px;
        }
        #feedback-result {
            font-weight: bold;
        }
        #feedback-explanation, #feedback-example {
            margin-top: 10px;
            font-size: 14px;
            color: #333;
        }
        #feedback-example {
            font-family: monospace;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
        }
        .correct {
            color: #4caf50;
        }
        .incorrect {
            color: #f44336;
        }
        #next-btn {
            display: none;
            margin: 20px auto;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        #next-btn:hover {
            background-color: #0056b3;
        }
        #results {
            margin-top: 20px;
            padding: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
        }
        #restart-btn {
            display: none;
            margin: 20px auto;
            padding: 10px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        #restart-btn:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>
    <h1>JavaScript Quiz with Instant Feedback</h1>
    <div id="level-selector">
        <label for="level">Select Difficulty Level: </label>
        <select id="level" onchange="startQuiz()">
            <option value="">Select a level</option>
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
        </select>
    </div>
    <div id="quiz-container" style="display: none;">
        <div id="question"></div>
        <div id="answers"></div>
        <div id="feedback">
            <div id="feedback-result"></div>
            <div id="feedback-explanation"></div>
            <div id="feedback-example"></div>
        </div>
        <button id="next-btn" onclick="nextQuestion()">Next Question</button>
    </div>
    <div id="results" style="display: none;"></div>
    <button id="restart-btn" style="display: none;" onclick="restartQuiz()">Restart Quiz</button>

    <script>
        
        const quizData = {
  "1": [
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `try` block contains code that might throw an error.",
          "answer": true,
          "explanation": "The `try` block is used to wrap code that may cause a runtime error, allowing the `catch` block to handle it.",
          "example": "try { console.log(undefinedVar); } catch (error) { console.log(error.message); } // Outputs: undefinedVar is not defined"
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "What happens if no error occurs in a `try` block?",
          "options": {
            "1": "The `catch` block is executed",
            "2": "The `catch` block is skipped",
            "3": "The program crashes",
            "4": "An error is thrown"
          },
          "answer": "2",
          "explanation": "If no error occurs in the `try` block, the `catch` block is skipped, and execution continues normally.",
          "example": "try { console.log('No error'); } catch (error) { console.log('Error'); } // Outputs: No error"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `catch` block receives an error object when an error is thrown.",
          "answer": true,
          "explanation": "The `catch` block receives an error object containing details like `name` and `message`.",
          "example": "try { throw new Error('Test'); } catch (error) { console.log(error.message); } // Outputs: Test"
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "What type of error is thrown when accessing an undefined variable?",
          "options": {
            "1": "SyntaxError",
            "2": "TypeError",
            "3": "ReferenceError",
            "4": "RangeError"
          },
          "answer": "3",
          "explanation": "A `ReferenceError` is thrown when trying to access a variable that is not defined.",
          "example": "try { console.log(undefinedVar); } catch (error) { console.log(error.name); } // Outputs: ReferenceError"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "`try-catch` can handle runtime errors but not syntax errors.",
          "answer": true,
          "explanation": "Syntax errors occur during parsing and prevent code execution, so `try-catch` cannot catch them.",
          "example": "// SyntaxError: try { eval('let x ='); } catch (error) { console.log(error); } // Not reached"
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "What is the output of `try { JSON.parse('{}'); } catch (error) { console.log('Error'); }`?",
          "options": {
            "1": "Error",
            "2": "Nothing",
            "3": "undefined",
            "4": "SyntaxError"
          },
          "answer": "2",
          "explanation": "The JSON is valid, so no error is thrown, and the `catch` block is skipped.",
          "example": "try { JSON.parse('{}'); } catch (error) { console.log('Error'); } // Outputs: Nothing"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `finally` block executes regardless of whether an error occurs.",
          "answer": true,
          "explanation": "The `finally` block runs after the `try` or `catch` block, ensuring cleanup or final actions.",
          "example": "try { console.log('Try'); } catch (error) {} finally { console.log('Finally'); } // Outputs: Try \n Finally"
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "What is the output of `try { throw new Error('Test'); } catch (error) { console.log(error.message); }`?",
          "options": {
            "1": "Test",
            "2": "Error",
            "3": "undefined",
            "4": "null"
          },
          "answer": "1",
          "explanation": "The `catch` block logs the `message` property of the thrown `Error` object.",
          "example": "try { throw new Error('Test'); } catch (error) { console.log(error.message); } // Outputs: Test"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Logical errors cannot be caught by `try-catch`.",
          "answer": true,
          "explanation": "Logical errors produce incorrect results but don’t throw exceptions, so `try-catch` cannot handle them.",
          "example": "try { let x = undefined + 10; console.log(x); } catch (error) { console.log(error); } // Outputs: NaN"
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "Which property of an error object provides the error type?",
          "options": {
            "1": "message",
            "2": "name",
            "3": "stack",
            "4": "type"
          },
          "answer": "2",
          "explanation": "The `name` property indicates the error type (e.g., 'ReferenceError').",
          "example": "try { throw new Error('Test'); } catch (error) { console.log(error.name); } // Outputs: Error"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `throw` statement can create a custom error.",
          "answer": true,
          "explanation": "The `throw` statement creates an error that triggers the `catch` block.",
          "example": "try { throw new Error('Custom'); } catch (error) { console.log(error.message); } // Outputs: Custom"
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "What is the output of `try { let x = 1 / 0; } catch (error) { console.log('Error'); }`?",
          "options": {
            "1": "Error",
            "2": "Infinity",
            "3": "Nothing",
            "4": "undefined"
          },
          "answer": "3",
          "explanation": "Dividing by zero in JavaScript returns `Infinity`, not an error, so the `catch` block is skipped.",
          "example": "try { let x = 1 / 0; } catch (error) { console.log('Error'); } // Outputs: Nothing"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `error.stack` property provides a stack trace for debugging.",
          "answer": true,
          "explanation": "The `stack` property (non-standard but widely supported) shows the call stack at the time of the error.",
          "example": "try { throw new Error('Test'); } catch (error) { console.log(error.stack); } // Outputs stack trace"
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "What type of error is thrown when calling a non-function?",
          "options": {
            "1": "ReferenceError",
            "2": "TypeError",
            "3": "SyntaxError",
            "4": "RangeError"
          },
          "answer": "2",
          "explanation": "A `TypeError` is thrown when an operation is performed on an invalid type, like calling a non-function.",
          "example": "try { let x = 42; x(); } catch (error) { console.log(error.name); } // Outputs: TypeError"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Empty `catch` blocks are considered bad practice.",
          "answer": true,
          "explanation": "Empty `catch` blocks lead to silent failures, hiding errors and complicating debugging.",
          "example": "try { throw new Error('Test'); } catch (error) {} // Bad: silent failure"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Primitive values like numbers and strings are stored directly in the stack memory.",
          "answer": true,
          "explanation": "Primitive types (numbers, strings, booleans, etc.) are stored in the stack due to their fixed size and fast access requirements.",
          "example": "let x = 42; let str = 'Hello'; // Both x and str are stored in the stack."
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "Where is the reference to an object stored in JavaScript?",
          "options": {
            "1": "Heap",
            "2": "Stack",
            "3": "Global scope",
            "4": "Nowhere"
          },
          "answer": "2",
          "explanation": "The reference to an object (e.g., variable name) is stored in the stack, while the object itself is stored in the heap.",
          "example": "let obj = { key: 'value' }; // obj reference in stack, object in heap."
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The stack memory operates on a Last In, First Out (LIFO) pattern.",
          "answer": true,
          "explanation": "The stack uses a LIFO structure, where the last item pushed (e.g., a function call) is the first to be popped.",
          "example": "function a() { b(); } function b() { console.log('b'); } a(); // Stack manages calls."
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "What happens when you assign a new value to a primitive variable?",
          "options": {
            "1": "A new heap allocation is created",
            "2": "The stack memory is updated",
            "3": "The garbage collector is triggered",
            "4": "An error occurs"
          },
          "answer": "2",
          "explanation": "Primitives are stored in the stack, and reassigning updates the stack memory directly.",
          "example": "let x = 10; x = 20; // Stack updates x to 20."
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Objects and arrays are stored in the heap memory.",
          "answer": true,
          "explanation": "Dynamic data like objects and arrays are stored in the heap due to their variable size.",
          "example": "let arr = [1, 2]; let obj = { a: 1 }; // Both stored in heap."
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "What is the output of `let a = 5; let b = a; b = 10; console.log(a);`?",
          "options": {
            "1": "5",
            "2": "10",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "Primitives are passed by value, so `b` is a copy of `a` in the stack. Changing `b` doesn’t affect `a`.",
          "example": "let a = 5; let b = a; b = 10; console.log(a); // Outputs: 5"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Function calls create stack frames to manage local variables.",
          "answer": true,
          "explanation": "Each function call creates a stack frame in the call stack to store local variables and execution context.",
          "example": "function test() { let x = 1; } test(); // Stack frame created and popped."
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "Where is a function’s code stored in JavaScript?",
          "options": {
            "1": "Stack",
            "2": "Heap",
            "3": "Global scope",
            "4": "Browser cache"
          },
          "answer": "2",
          "explanation": "Functions are objects in JavaScript and are stored in the heap, with their references in the stack.",
          "example": "let fn = function() {}; // fn in stack, function in heap."
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Setting a variable to `null` removes its reference from the stack.",
          "answer": true,
          "explanation": "Setting a variable to `null` updates its stack value, removing the reference to heap data.",
          "example": "let obj = { key: 1 }; obj = null; // Reference removed."
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "What happens to a primitive variable when its function scope ends?",
          "options": {
            "1": "It is garbage-collected",
            "2": "Its stack frame is popped",
            "3": "It moves to the heap",
            "4": "It becomes global"
          },
          "answer": "2",
          "explanation": "When a function scope ends, its stack frame is popped, freeing primitive variables.",
          "example": "function test() { let x = 10; } test(); // x is removed from stack."
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The heap memory is slower than the stack memory for allocation.",
          "answer": true,
          "explanation": "Heap memory allocation is slower due to its dynamic and fragmented nature compared to the stack’s sequential structure.",
          "example": "let obj = { a: 1 }; // Heap allocation is slower than let x = 1;"
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "What is the output of `let obj1 = { value: 10 }; let obj2 = obj1; obj2.value = 20; console.log(obj1.value);`?",
          "options": {
            "1": "10",
            "2": "20",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "Objects are passed by reference; both variables point to the same heap object, so modifying `obj2` affects `obj1`.",
          "example": "let obj1 = { value: 10 }; let obj2 = obj1; obj2.value = 20; console.log(obj1.value); // Outputs: 20"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The stack memory is used to manage function call execution.",
          "answer": true,
          "explanation": "The stack manages function calls via stack frames, which store local variables and execution context.",
          "example": "function a() { let x = 1; } a(); // Stack frame created and popped."
        }
      ]
    },
    {
      "type": 2,
      "level": "easy",
      "question": [
        {
          "question": "Which of the following is stored in the stack?",
          "options": {
            "1": "An object",
            "2": "An array",
            "3": "A string",
            "4": "A function"
          },
          "answer": "3",
          "explanation": "Strings are primitives and stored in the stack, while objects, arrays, and functions are stored in the heap.",
          "example": "let str = 'Hello'; // Stored in stack."
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The garbage collector manages heap memory in JavaScript.",
          "answer": true,
          "explanation": "The garbage collector automatically deallocates unreachable objects in the heap to free memory.",
          "example": "let obj = { a: 1 }; obj = null; // Heap object becomes unreachable."
        }
      ]
    },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A variable declared in the global scope is accessible inside a function scope.",
        "answer": true,
        "explanation": "Variables in the global scope are accessible to all inner scopes, including function scopes, unless shadowed by a local declaration.",
        "example": "let globalVar = 'global'; function test() { console.log(globalVar); } test(); // Outputs: global"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let x = 'outer'; function test() { console.log(x); } test();`?",
        "options": {
          "1": "outer",
          "2": "undefined",
          "3": "ReferenceError",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The function `test` accesses the global variable `x` because it is in the outer scope.",
        "example": "let x = 'outer'; function test() { console.log(x); } test(); // Outputs: outer"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A variable declared with `let` inside an `if` block is accessible outside that block.",
        "answer": false,
        "explanation": "Variables declared with `let` in a block scope (e.g., `if` block) are not accessible outside that block due to block scoping.",
        "example": "if (true) { let x = 1; } console.log(x); // ReferenceError: x is not defined"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `function test() { let x = 'inner'; console.log(x); } test();`?",
        "options": {
          "1": "inner",
          "2": "undefined",
          "3": "ReferenceError",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The variable `x` is declared in the function scope of `test` and is accessible within that function.",
        "example": "function test() { let x = 'inner'; console.log(x); } test(); // Outputs: inner"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A function scope can access variables from the global scope.",
        "answer": true,
        "explanation": "Function scope has access to variables in its outer scope, including the global scope, following the scope chain.",
        "example": "let global = 'global'; function test() { console.log(global); } test(); // Outputs: global"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What happens when you try to access a block-scoped variable outside its block? `if (true) { let x = 5; } console.log(x);`",
        "options": {
          "1": "Outputs 5",
          "2": "Outputs undefined",
          "3": "ReferenceError",
          "4": "null"
        },
        "answer": "3",
        "explanation": "Variables declared with `let` in a block scope are not accessible outside the block, resulting in a ReferenceError.",
        "example": "if (true) { let x = 5; } console.log(x); // ReferenceError: x is not defined"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A variable declared with `var` in a function is limited to that function’s scope.",
        "answer": true,
        "explanation": "Variables declared with `var` inside a function are function-scoped and not accessible outside the function.",
        "example": "function test() { var x = 1; } test(); console.log(x); // ReferenceError: x is not defined"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let x = 'global'; function test() { let x = 'local'; console.log(x); } test();`?",
        "options": {
          "1": "global",
          "2": "local",
          "3": "ReferenceError",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The local variable `x` in the function shadows the global `x`, so the function logs the local value.",
        "example": "let x = 'global'; function test() { let x = 'local'; console.log(x); } test(); // Outputs: local"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A closure allows an inner function to access variables from its outer function scope.",
        "answer": true,
        "explanation": "A closure is created when an inner function retains access to variables from its outer function scope, even after the outer function finishes executing.",
        "example": "function outer() { let x = 1; return function() { console.log(x); }; } let fn = outer(); fn(); // Outputs: 1"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `function outer() { let x = 10; return function() { console.log(x); }; } let fn = outer(); fn();`?",
        "options": {
          "1": "10",
          "2": "undefined",
          "3": "ReferenceError",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The inner function forms a closure, retaining access to `x` from the outer function’s scope, and logs its value.",
        "example": "function outer() { let x = 10; return function() { console.log(x); }; } let fn = outer(); fn(); // Outputs: 10"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "Variables declared with `const` in a block scope are accessible outside the block.",
        "answer": false,
        "explanation": "Variables declared with `const` in a block scope are limited to that block and cause a ReferenceError if accessed outside.",
        "example": "if (true) { const x = 1; } console.log(x); // ReferenceError: x is not defined"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let global = 'global'; function test() { console.log(global); } test();`?",
        "options": {
          "1": "global",
          "2": "undefined",
          "3": "ReferenceError",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The function `test` accesses the global variable `global` via the scope chain.",
        "example": "let global = 'global'; function test() { console.log(global); } test(); // Outputs: global"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A function cannot access variables declared in a sibling function’s scope.",
        "answer": true,
        "explanation": "Functions can only access their own scope and outer scopes, not sibling scopes, as they are separate contexts.",
        "example": "function a() { let x = 1; } function b() { console.log(x); } b(); // ReferenceError: x is not defined"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `for (let i = 0; i < 2; i++) { console.log(i); } console.log(i);`?",
        "options": {
          "1": "0, 1",
          "2": "0, 1, undefined",
          "3": "0, 1, ReferenceError",
          "4": "Error"
        },
        "answer": "3",
        "explanation": "The variable `i` is block-scoped with `let` in the `for` loop, so accessing it outside the loop causes a ReferenceError.",
        "example": "for (let i = 0; i < 2; i++) { console.log(i); } console.log(i); // Outputs: 0, 1, ReferenceError"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A closure is created whenever a function is defined inside another function.",
        "answer": true,
        "explanation": "A closure is formed when an inner function is defined within an outer function and has access to the outer function’s variables.",
        "example": "function outer() { let x = 1; function inner() { console.log(x); } return inner; } let fn = outer(); fn(); // Outputs: 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "An `if` statement executes its code block only if the condition evaluates to `true`.",
        "answer": true,
        "explanation": "The `if` statement evaluates a condition, and if it is `true`, the associated code block is executed. If `false`, the block is skipped.",
        "example": "let x = 5; if (x > 0) { console.log('Positive'); } // Outputs: Positive"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let x = 10; if (x === '10') { console.log('Equal'); } else { console.log('Not equal'); }`?",
        "options": {
          "1": "Equal",
          "2": "Not equal",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "The `===` operator checks both value and type. Since `x` is a number (10) and `'10'` is a string, the condition is `false`, so the `else` block executes.",
        "example": "let x = 10; if (x === '10') { console.log('Equal'); } else { console.log('Not equal'); } // Outputs: Not equal"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A `for` loop requires a counter variable to be declared with `let` inside the loop statement.",
        "answer": false,
        "explanation": "A `for` loop does not require the counter variable to be declared with `let` inside the loop; it can use `var`, `let`, or an existing variable. Using `let` ensures block scope.",
        "example": "let i = 0; for (i; i < 3; i++) { console.log(i); } // Outputs: 0, 1, 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does the following `switch` statement output? `let value = 2; switch (value) { case 1: console.log('One'); break; case 2: console.log('Two'); break; default: console.log('Default'); }`",
        "options": {
          "1": "One",
          "2": "Two",
          "3": "Default",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "The `switch` statement matches `value` to `case 2`, executes `console.log('Two')`, and exits due to `break`.",
        "example": "let value = 2; switch (value) { case 1: console.log('One'); break; case 2: console.log('Two'); break; default: console.log('Default'); } // Outputs: Two"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A `while` loop continues executing as long as its condition is `true`.",
        "answer": true,
        "explanation": "A `while` loop evaluates its condition before each iteration, executing the code block only if the condition is `true`.",
        "example": "let i = 0; while (i < 2) { console.log(i); i++; } // Outputs: 0, 1"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let i = 0; do { console.log(i); i++; } while (i < 1);`?",
        "options": {
          "1": "0",
          "2": "1",
          "3": "0, 1",
          "4": "Nothing"
        },
        "answer": "1",
        "explanation": "A `do...while` loop executes at least once. Here, it logs `0` and increments `i` to 1, then stops as the condition `i < 1` is `false`.",
        "example": "let i = 0; do { console.log(i); i++; } while (i < 1); // Outputs: 0"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "The `break` statement can be used to exit a `for` loop early.",
        "answer": true,
        "explanation": "The `break` statement immediately exits a loop, stopping further iterations.",
        "example": "for (let i = 0; i < 3; i++) { if (i === 1) break; console.log(i); } // Outputs: 0"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let x = 5; if (x > 0 && x < 10) { console.log('In range'); }`?",
        "options": {
          "1": "In range",
          "2": "Nothing",
          "3": "Error",
          "4": "undefined"
        },
        "answer": "1",
        "explanation": "The `&&` operator requires both conditions to be `true`. Since `x > 0` and `x < 10` are both `true`, the `if` block executes.",
        "example": "let x = 5; if (x > 0 && x < 10) { console.log('In range'); } // Outputs: In range"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "The `continue` statement skips the current iteration of a loop and proceeds to the next one.",
        "answer": true,
        "explanation": "The `continue` statement skips the rest of the current iteration and moves to the next iteration of the loop.",
        "example": "for (let i = 0; i < 3; i++) { if (i === 1) continue; console.log(i); } // Outputs: 0, 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let x = 15; console.log(x > 10 ? 'High' : 'Low');`?",
        "options": {
          "1": "High",
          "2": "Low",
          "3": "Error",
          "4": "undefined"
        },
        "answer": "1",
        "explanation": "The ternary operator evaluates `x > 10`. Since it’s `true`, it returns `'High'`.",
        "example": "let x = 15; console.log(x > 10 ? 'High' : 'Low'); // Outputs: High"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "The `else` block is required in an `if` statement.",
        "answer": false,
        "explanation": "An `else` block is optional in an `if` statement. The `if` block can stand alone.",
        "example": "let x = 5; if (x > 0) { console.log('Positive'); } // Outputs: Positive"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `for (let i = 0; i < 2; i++) { console.log('Loop'); }`?",
        "options": {
          "1": "Loop",
          "2": "Loop Loop",
          "3": "Nothing",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "The `for` loop iterates twice (i = 0, 1), logging 'Loop' each time.",
        "example": "for (let i = 0; i < 2; i++) { console.log('Loop'); } // Outputs: Loop, Loop"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A `switch` statement requires a `default` case.",
        "answer": false,
        "explanation": "The `default` case in a `switch` statement is optional and executes only if no other cases match.",
        "example": "let x = 1; switch (x) { case 1: console.log('One'); break; } // Outputs: One"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let x = false; x || console.log('Executed');`?",
        "options": {
          "1": "Executed",
          "2": "Nothing",
          "3": "Error",
          "4": "false"
        },
        "answer": "1",
        "explanation": "The `||` operator evaluates to the first truthy value or the last value. Since `x` is `false`, the second expression (`console.log('Executed')`) is evaluated, logging 'Executed'.",
        "example": "let x = false; x || console.log('Executed'); // Outputs: Executed"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A `do...while` loop executes at least once, even if the condition is `false`.",
        "answer": true,
        "explanation": "A `do...while` loop executes its block at least once before checking the condition.",
        "example": "let i = 0; do { console.log('Run'); i++; } while (i < 0); // Outputs: Run"
      }
    ]
  },
    {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A function declaration in JavaScript is hoisted, allowing it to be called before its definition.",
        "answer": true,
        "explanation": "Function declarations are fully hoisted, meaning their entire definition is moved to the top of the scope during compilation, allowing calls before the declaration.",
        "example": "greet(); function greet() { console.log('Hello!'); } // Hello!"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A function in JavaScript can be assigned to a variable.",
        "answer": true,
        "explanation": "Functions are first-class objects in JavaScript, meaning they can be assigned to variables, passed as arguments, or returned from other functions.",
        "example": "const greet = function() { console.log('Hello!'); }; greet(); // Hello!"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A function without a `return` statement returns `undefined`.",
        "answer": true,
        "explanation": "If a function does not explicitly return a value, it implicitly returns `undefined`.",
        "example": "function noReturn() { console.log('Hi'); } console.log(noReturn()); // Hi, undefined"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "An arrow function can be used as a constructor with `new`.",
        "answer": false,
        "explanation": "Arrow functions cannot be used as constructors because they lack a `prototype` property and their own `this` binding.",
        "example": "const Fn = () => {}; new Fn(); // TypeError: Fn is not a constructor"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "Functions can accept multiple parameters in JavaScript.",
        "answer": true,
        "explanation": "Functions can accept zero or more parameters, which act as placeholders for values passed during invocation.",
        "example": "function add(a, b) { return a + b; } console.log(add(2, 3)); // 5"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "Which of the following is a valid way to create a function in JavaScript?",
        "options": {
          "1": "function greet() {}",
          "2": "const greet = () => {}",
          "3": "(function() {})()",
          "4": "All of the above"
        },
        "answer": "4",
        "explanation": "JavaScript supports multiple ways to create functions, including function declarations, arrow functions, and immediately invoked function expressions (IIFEs).",
        "example": "function greet() { console.log('Hi'); } const greet2 = () => console.log('Hi'); (function() { console.log('Hi'); })(); // All valid"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does `function sayHi() { console.log('Hi'); } sayHi();` output?",
        "options": {
          "1": "Hi",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Calling the function `sayHi` executes the `console.log('Hi')` statement, outputting 'Hi'.",
        "example": "function sayHi() { console.log('Hi'); } sayHi(); // Hi"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of `const fn = function() { return 'Hello'; }; console.log(fn());`?",
        "options": {
          "1": "Hello",
          "2": "undefined",
          "3": "function",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The function expression returns the string 'Hello' when called.",
        "example": "const fn = function() { return 'Hello'; }; console.log(fn()); // Hello"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "An IIFE (Immediately Invoked Function Expression) runs automatically without needing to be called explicitly.",
        "answer": true,
        "explanation": "An IIFE is executed immediately after its definition by wrapping it in parentheses and adding `()`.",
        "example": "(function() { console.log('Runs now!'); })(); // Runs now!"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "Functions in JavaScript cannot have properties like objects.",
        "answer": false,
        "explanation": "Functions are first-class objects in JavaScript and can have properties and methods like any other object.",
        "example": "function fn() {} fn.prop = 'test'; console.log(fn.prop); // test"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does `const double = x => x * 2; console.log(double(5));` return?",
        "options": {
          "1": "10",
          "2": "5",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The arrow function `double` multiplies its input by 2, so `double(5)` returns 10.",
        "example": "const double = x => x * 2; console.log(double(5)); // 10"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A function can return another function in JavaScript.",
        "answer": true,
        "explanation": "Functions are first-class objects and can return other functions, enabling higher-order functions and closures.",
        "example": "function outer() { return function() { console.log('Inner'); }; } const fn = outer(); fn(); // Inner"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "Which method is NOT a valid way to create a function in JavaScript?",
        "options": {
          "1": "function greet() {}",
          "2": "const greet = function() {}",
          "3": "let greet = () => {}",
          "4": "greet() {}"
        },
        "answer": "4",
        "explanation": "The syntax `greet() {}` is invalid. Valid methods include function declarations, function expressions, and arrow functions.",
        "example": "function greet() {} // Valid; const greet2 = function() {} // Valid; const greet3 = () => {} // Valid"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "Functions can be passed as arguments to other functions.",
        "answer": true,
        "explanation": "As first-class objects, functions can be passed as arguments, enabling higher-order functions.",
        "example": "function callFn(fn) { fn(); } callFn(() => console.log('Called')); // Called"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does `(function(name) { console.log(name); })('Alice');` output?",
        "options": {
          "1": "Alice",
          "2": "undefined",
          "3": "Error",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The IIFE takes a parameter `name` and logs it when invoked with 'Alice'.",
        "example": "(function(name) { console.log(name); })('Alice'); // Alice"
      }
    ]
  },
    {
  "type": 2,
  "level": "easy",
  "question": [
    {
      "question": "What does `Object.freeze({ name: 'Luiz' })` do?",
      "options": {
        "1": "Prevents property modifications",
        "2": "Deletes all properties",
        "3": "Makes properties enumerable",
        "4": "Throws an error"
      },
      "answer": "1",
      "explanation": "`Object.freeze()` makes an object immutable, preventing additions, deletions, or modifications of its properties.",
      "example": "let obj = Object.freeze({ name: 'Luiz' }); obj.name = 'Marta'; console.log(obj.name); // 'Luiz'"
    }
  ]
},
    {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of calling toString() on an object created with Object Literal syntax?",
        "options": {
          "1": "[object Object]",
          "2": "undefined",
          "3": "Object Literal",
          "4": "null"
        },
        "answer": "1",
        "explanation": "Objects created with Object Literal syntax inherit from Object.prototype, which provides the toString() method returning '[object Object]' by default.",
        "example": "let obj = { name: 'Luiz' };console.log(obj.toString()); // '[object Object]'"
      }
    ]
    },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "Which method checks if a property is an own property of an object, not inherited from its prototype?",
        "options": {
          "1": "Object.getPrototypeOf()",
          "2": "hasOwnProperty()",
          "3": "toString()",
          "4": "Object.setPrototypeOf()"
        },
        "answer": "2",
        "explanation": "hasOwnProperty() is a method on Object.prototype that checks if a property exists directly on the object, not inherited via the prototype chain.",
        "example": "let obj = { name: 'Luiz' };console.log(obj.hasOwnProperty('name')); // trueconsole.log(obj.hasOwnProperty('toString')); // false"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the prototype of an object created with new Object()?",
        "options": {
          "1": "null",
          "2": "Object.prototype",
          "3": "Function.prototype",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "Objects created with new Object() inherit from Object.prototype, which provides methods like toString() and hasOwnProperty().",
        "example": "let obj = new Object();console.log(Object.getPrototypeOf(obj) === Object.prototype); // true"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does Object.getPrototypeOf() return for an object created with Object.create(null)?",
        "options": {
          "1": "Object.prototype",
          "2": "null",
          "3": "Function.prototype",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "Object.create(null) creates an object with no prototype, so Object.getPrototypeOf() returns null.",
        "example": "let obj = Object.create(null);console.log(Object.getPrototypeOf(obj)); // null"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of accessing a non-existent property on an object created with Object Literal syntax?",
        "options": {
          "1": "null",
          "2": "undefined",
          "3": "throws an error",
          "4": "empty string"
        },
        "answer": "2",
        "explanation": "Accessing a non-existent property on an object returns undefined, as the prototype chain is traversed until null is reached.",
        "example": "let obj = { name: 'Luiz' };console.log(obj.age); // undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "Which syntax defines a method on a Constructor Function’s prototype?",
        "options": {
          "1": "function Person() { this.greet = () => 'Hi!'; }",
          "2": "Person.prototype.greet = function() { return 'Hi!'; };",
          "3": "let obj = new Person(); obj.greet = () => 'Hi!';",
          "4": "Person.greet = function() { return 'Hi!'; };"
        },
        "answer": "2",
        "explanation": "Person.prototype.greet adds a method to the prototype, shared by all instances. Option 1 adds it to each instance, option 3 to a single instance, and option 4 to the constructor function itself.",
        "example": "function Person() {}Person.prototype.greet = function() { return 'Hi!'; };let p = new Person();console.log(p.greet()); // 'Hi!'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the prototype of an instance created with a Class Syntax constructor?",
        "options": {
          "1": "Class.prototype",
          "2": "Object.prototype",
          "3": "Function.prototype",
          "4": "null"
        },
        "answer": "1",
        "explanation": "Instances created with Class Syntax inherit from the class’s prototype (e.g., Person.prototype), not directly from Object.prototype or Function.prototype.",
        "example": "class Person {}let p = new Person();console.log(Object.getPrototypeOf(p) === Person.prototype); // true"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does the following code log: let obj = Object.create({ name: 'Luiz' }); console.log(obj.name);?",
        "options": {
          "1": "Luiz",
          "2": "undefined",
          "3": "null",
          "4": "throws an error"
        },
        "answer": "1",
        "explanation": "Object.create() sets the specified object as the prototype, so obj.name accesses the inherited name property from the prototype.",
        "example": "let obj = Object.create({ name: 'Luiz' });console.log(obj.name); // 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of calling hasOwnProperty('toString') on an Object Literal?",
        "options": {
          "1": "true",
          "2": "false",
          "3": "undefined",
          "4": "null"
        },
        "answer": "2",
        "explanation": "toString is inherited from Object.prototype, not an own property, so hasOwnProperty('toString') returns false.",
        "example": "let obj = {};console.log(obj.hasOwnProperty('toString')); // false"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does the following Factory Function return: function createPerson(name) { return { name }; }?",
        "options": {
          "1": "An object with Object.prototype as its prototype",
          "2": "An object with Function.prototype as its prototype",
          "3": "An object with no prototype",
          "4": "A function"
        },
        "answer": "1",
        "explanation": "Factory Functions return objects that inherit from Object.prototype by default unless customized.",
        "example": "function createPerson(name) { return { name }; }let p = createPerson('Luiz');console.log(Object.getPrototypeOf(p) === Object.prototype); // true"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the prototype of a Constructor Function itself?",
        "options": {
          "1": "Object.prototype",
          "2": "Function.prototype",
          "3": "null",
          "4": "Person.prototype"
        },
        "answer": "2",
        "explanation": "Constructor Functions are functions, so they inherit from Function.prototype, which chains to Object.prototype.",
        "example": "function Person() {}console.log(Object.getPrototypeOf(Person) === Function.prototype); // true"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does the following code log: class Person { greet() { return 'Hi!'; } } let p = new Person(); console.log(p.greet());?",
        "options": {
          "1": "Hi!",
          "2": "undefined",
          "3": "throws an error",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The greet method is defined on Person.prototype and inherited by the instance p, so p.greet() returns 'Hi!'.",
        "example": "class Person {  greet() { return 'Hi!'; }}let p = new Person();console.log(p.greet()); // 'Hi!'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of adding a property to Person.prototype and accessing it from an instance?",
        "options": {
          "1": "The property is accessible",
          "2": "The property is undefined",
          "3": "Throws an error",
          "4": "The property is null"
        },
        "answer": "1",
        "explanation": "Properties added to Person.prototype are inherited by all instances of Person, making them accessible.",
        "example": "function Person() {}Person.prototype.role = 'Student';let p = new Person();console.log(p.role); // 'Student'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does Object.getPrototypeOf({}) return?",
        "options": {
          "1": "Object.prototype",
          "2": "null",
          "3": "Function.prototype",
          "4": "undefined"
        },
        "answer": "1",
        "explanation": "Objects created with Object Literal syntax ({}) inherit from Object.prototype.",
        "example": "let obj = {};console.log(Object.getPrototypeOf(obj) === Object.prototype); // true"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of calling a method defined on a Constructor Function’s prototype?",
        "options": {
          "1": "The method executes",
          "2": "undefined",
          "3": "Throws an error",
          "4": "null"
        },
        "answer": "1",
        "explanation": "Methods defined on a Constructor Function’s prototype are inherited by instances and can be called.",
        "example": "function Person() {}Person.prototype.greet = function() { return 'Hello!'; };\nlet p = new Person();\nconsole.log(p.greet()); // 'Hello!'"
      }
    ]
  },
      {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "An object created with object literal syntax using `{}` is immediately usable without requiring a constructor.",
        "answer": true,
        "explanation": "Object literal syntax `{}` creates an object directly, allowing immediate property and method assignments without a constructor function.",
        "example": "let obj = { name: 'Luiz' }; console.log(obj.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A `const` object cannot have its properties modified.",
        "answer": false,
        "explanation": "A `const` object prevents reassignment of the object reference, but its properties can still be modified as objects are mutable.",
        "example": "const obj = { name: 'Luiz' }; obj.name = 'Marta'; console.log(obj.name); \n// 'Marta'"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "The `new Object()` constructor creates an empty object by default.",
        "answer": true,
        "explanation": "The `new Object()` constructor creates an empty object, which can then have properties and methods assigned to it.",
        "example": "let obj = new Object(); console.log(Object.keys(obj)); \n// []"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "Factory Functions return a new object each time they are called.",
        "answer": true,
        "explanation": "Factory Functions return a new object with the specified structure every time they are invoked, without relying on `this` or prototypes.",
        "example": "function createObj() { return { name: 'Luiz' }; } console.log(createObj().name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "The Class Syntax in JavaScript requires a `constructor` method to initialize properties.",
        "answer": false,
        "explanation": "While a `constructor` is commonly used in Class Syntax, it is not required; properties can be defined directly in the class body or methods.",
        "example": "class Person { name = 'Luiz'; } let p = new Person(); console.log(p.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let obj = { name: 'Luiz' }; console.log(obj.name);`?",
        "options": {
          "1": "'Luiz'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The object literal `{ name: 'Luiz' }` defines a property `name`, which is accessed using dot notation, returning 'Luiz'.",
        "example": "let obj = { name: 'Luiz' }; console.log(obj.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does `let obj = new Object(); obj.name = 'Luiz'; console.log(obj.name);` return?",
        "options": {
          "1": "'Luiz'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`new Object()` creates an empty object, and assigning `obj.name = 'Luiz'` adds the `name` property, which is then accessed.",
        "example": "let obj = new Object(); obj.name = 'Luiz'; console.log(obj.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `function createObj() { return { name: 'Luiz' }; } let obj = createObj(); console.log(obj.name);`?",
        "options": {
          "1": "'Luiz'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The Factory Function `createObj` returns a new object with a `name` property, which is accessed as `obj.name`.",
        "example": "function createObj() { return { name: 'Luiz' }; } let obj = createObj(); console.log(obj.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does `class Person { constructor(name) { this.name = name; } } let p = new Person('Luiz'); console.log(p.name);` return?",
        "options": {
          "1": "'Luiz'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `Person` class constructor sets the `name` property, which is accessed on the instance `p`.",
        "example": "class Person { constructor(name) { this.name = name; } } let p = new Person('Luiz'); console.log(p.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let proto = { greet: () => 'Hi' }; let obj = Object.create(proto); console.log(obj.greet());`?",
        "options": {
          "1": "'Hi'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`Object.create(proto)` creates an object with `proto` as its prototype, inheriting the `greet` method, which returns 'Hi'.",
        "example": "let proto = { greet: () => 'Hi' }; let obj = Object.create(proto); console.log(obj.greet()); \n// 'Hi'"
      }
    ]
  },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Objects in JavaScript are unordered collections of key-value pairs.",
          "answer": true,
          "explanation": "Objects in JavaScript are indeed unordered collections of key-value pairs, where keys are typically strings or symbols, and values can be any data type. Unlike arrays, objects do not maintain a specific order for their properties.",
          "example": "let obj = { name: 'Luiz', age: 29 }; \nconsole.log(obj); \n// { name: 'Luiz', age: 29 } (order may vary)"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Object keys in JavaScript can only be strings.",
          "answer": false,
          "explanation": "Object keys can be strings or symbols. While strings are the most common, symbols can also be used as unique property keys since ES6.",
          "example": "let sym = Symbol('key'); \nlet obj = { 'name': 'Luiz', [sym]: 42 }; \nconsole.log(Object.getOwnPropertySymbols(obj)); \n// [Symbol(key)]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "An object declared with `const` cannot have its properties modified.",
          "answer": false,
          "explanation": "Using `const` prevents reassignment of the object reference, but the object's properties can still be modified because objects are mutable by default.",
          "example": "const obj = { name: 'Luiz' }; \nobj.name = 'Marta'; \nconsole.log(obj); \n// { name: 'Marta' }"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Accessing a non-existent property in an object returns `undefined`.",
          "answer": true,
          "explanation": "When a property does not exist in an object, accessing it with dot or bracket notation returns `undefined`.",
          "example": "let obj = { name: 'Luiz' }; \nconsole.log(obj.age); \n// undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `typeof` operator returns 'object' for an object in JavaScript.",
          "answer": true,
          "explanation": "The `typeof` operator returns 'object' for objects, including those created with object literals, constructors, or classes.",
          "example": "let obj = { name: 'Luiz' }; \nconsole.log(typeof obj); \n// 'object'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Objects can be created using the object literal syntax `{}`.",
          "answer": true,
          "explanation": "The object literal syntax `{}` is a common and concise way to create objects in JavaScript.",
          "example": "let obj = {}; \nobj.name = 'Luiz'; \nconsole.log(obj); \n// { name: 'Luiz' }"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Bracket notation `object['key']` can be used to access properties dynamically.",
          "answer": true,
          "explanation": "Bracket notation allows dynamic property access using a string or variable, useful for invalid identifiers or computed property names.",
          "example": "let obj = { color: 'blue' }; \nlet key = 'color'; \nconsole.log(obj[key]); \n// 'blue'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Objects in JavaScript are copied by value when assigned to a new variable.",
          "answer": false,
          "explanation": "Objects are copied by reference, so assigning an object to a new variable points to the same memory location, and changes affect the original.",
          "example": "let obj = { name: 'Luiz' }; \nlet copy = obj; \ncopy.name = 'Marta'; \nconsole.log(obj.name); \n// 'Marta'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `delete` operator can remove any property from an object, including inherited ones.",
          "answer": false,
          "explanation": "The `delete` operator only removes own properties of an object, not inherited properties from its prototype.",
          "example": "let proto = { name: 'Luiz' }; \nlet obj = Object.create(proto); \ndelete obj.name; \nconsole.log(obj.name); \n// 'Luiz' (inherited, not deleted)"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Objects can contain other objects as property values.",
          "answer": true,
          "explanation": "Objects can have nested objects as property values, allowing complex data structures.",
          "example": "let obj = { info: { city: 'New York' } }; \nconsole.log(obj.info.city); \n// 'New York'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Arrays in JavaScript can store elements of different types, such as numbers, strings, and objects.",
          "answer": true,
          "explanation": "Arrays in JavaScript are flexible and can hold elements of any type, including mixed types like numbers, strings, and objects.",
          "example": "let arr = [1, 'hello', { name: 'Luiz' }]; \nconsole.log(arr); \n// [1, 'hello', { name: 'Luiz' }]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `.length` property of an array returns the number of elements, including undefined ones in sparse arrays.",
          "answer": true,
          "explanation": "The `.length` property reflects the highest index plus one, including undefined elements in sparse arrays.",
          "example": "let arr = []; \narr[5] = 'x'; \nconsole.log(arr.length); \n// 6"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Arrays in JavaScript are immutable, meaning their elements cannot be changed directly.",
          "answer": false,
          "explanation": "Arrays are mutable, allowing their elements to be modified directly via index access or methods.",
          "example": "let arr = [1, 2]; \narr[0] = 3; \nconsole.log(arr); \n// [3, 2]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "An empty array has a `.length` of 0.",
          "answer": true,
          "explanation": "An empty array, created with `[]` or `new Array()`, has a `.length` of 0 since it contains no elements.",
          "example": "let arr = []; \nconsole.log(arr.length); \n// 0"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `typeof` operator returns 'array' for an array in JavaScript.",
          "answer": false,
          "explanation": "The `typeof` operator returns 'object' for arrays, as arrays are a type of object in JavaScript.",
          "example": "let arr = [1, 2, 3]; \nconsole.log(typeof arr); \n// 'object'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Arrays in JavaScript can be created using the `Array` constructor.",
          "answer": true,
          "explanation": "Arrays can be created using the `Array` constructor, such as `new Array()` or `Array()`, in addition to the literal syntax `[]`.",
          "example": "let arr = new Array(1, 2, 3); \nconsole.log(arr); \n// [1, 2, 3]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The first element of an array is accessed with index 1.",
          "answer": false,
          "explanation": "JavaScript arrays are zero-indexed, so the first element is accessed with index 0.",
          "example": "let arr = ['a', 'b']; \nconsole.log(arr[0]); \n// 'a'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "An array declared with `const` can have its elements modified.",
          "answer": true,
          "explanation": "Using `const` prevents reassignment of the array, but its elements can be modified because arrays are mutable.",
          "example": "const arr = [1, 2]; \narr[0] = 3; \nconsole.log(arr); \n// [3, 2]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Accessing an array with an index that does not exist returns `undefined`.",
          "answer": true,
          "explanation": "Accessing an array index that is out of bounds or undefined returns `undefined`.",
          "example": "let arr = [1, 2]; \nconsole.log(arr[5]); \n// undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Arrays in JavaScript are always stored as copies when assigned to a new variable.",
          "answer": false,
          "explanation": "Arrays are copied by reference, so assigning an array to a new variable points to the same memory location.",
          "example": "let arr = [1, 2]; \nlet copy = arr; \ncopy[0] = 3; \nconsole.log(arr); \n// [3, 2]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Strings in JavaScript can be created using single quotes, double quotes, or template literals.",
          "answer": true,
          "explanation": "Strings can be created with single quotes (`'`), double quotes (`\"`), or template literals (`` ` ``), all producing string primitives.",
          "example": "let s1 = 'hi'; \nlet s2 = \"hello\"; \nlet s3 = `world`; \nconsole.log(typeof s1, typeof s2, typeof s3); \n// 'string' 'string' 'string'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "An empty string has a length of 0.",
          "answer": true,
          "explanation": "An empty string (`''`) has no characters, so its `.length` property returns 0.",
          "example": "let str = ''; \nconsole.log(str.length); \n// 0"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "A string in JavaScript can contain numbers and special symbols like emojis.",
          "answer": true,
          "explanation": "Strings can include numbers, letters, special characters, and emojis, as they are sequences of UTF-16 code units.",
          "example": "let str = '123 😊'; \nconsole.log(str); \n// '123 😊'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Strings in JavaScript are mutable, meaning their original value can be changed directly.",
          "answer": false,
          "explanation": "Strings are immutable in JavaScript; \noperations like concatenation create new strings without modifying the original.",
          "example": "let str = 'hello'; \nstr[0] = 'x'; \nconsole.log(str); \n// 'hello' (unchanged)"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `.length` property of a string returns the number of characters, including spaces.",
          "answer": true,
          "explanation": "The `.length` property counts all characters in a string, including spaces and special characters.",
          "example": "let str = 'hi there'; \nconsole.log(str.length); \n// 8"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Booleans in JavaScript can only have two values: true or false.",
          "answer": true,
          "explanation": "Boolean primitives in JavaScript are strictly `true` or `false`, representing logical truth values.",
          "example": "let bool = true; \nconsole.log(bool); \n// true"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The typeof operator returns 'boolean' for a Boolean value.",
          "answer": true,
          "explanation": "The `typeof` operator returns 'boolean' for both primitive booleans and Boolean objects.",
          "example": "let bool = false; \nconsole.log(typeof bool); \n// 'boolean'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The logical NOT operator (!) inverts a Boolean value.",
          "answer": true,
          "explanation": "The `!` operator negates a boolean, turning `true` to `false` and vice versa.",
          "example": "let bool = true; \nconsole.log(!bool); \n// false"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Booleans can be used in if statements to control program flow.",
          "answer": true,
          "explanation": "Booleans are commonly used in conditional statements like `if` to determine execution paths.",
          "example": "let bool = true; \nif (bool) { console.log('Run'); \n} // 'Run'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "A Boolean primitive has built-in methods like toString() without needing to be an object.",
          "answer": true,
          "explanation": "Due to autoboxing, Boolean primitives can use methods like `toString()` as if they were objects.",
          "example": "let bool = false; \nconsole.log(bool.toString()); \n// 'false'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The Number type in JavaScript can represent both integers and floating-point numbers.",
          "answer": true,
          "explanation": "The Number type in JavaScript includes both integers (e.g., 42) and floating-point numbers (e.g., 3.14).",
          "example": "let num1 = 42; \nlet num2 = 3.14; \nconsole.log(typeof num1, typeof num2); \n// 'number' 'number'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "All numbers in JavaScript are stored as 32-bit integers.",
          "answer": false,
          "explanation": "Numbers in JavaScript are stored as 64-bit floating-point values, per the IEEE 754 standard, not 32-bit integers.",
          "example": "let num = 3.14; \nconsole.log(num); \n// 3.14 (floating-point)"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "You can use scientific notation like `1e5` to represent numbers in JavaScript.",
          "answer": true,
          "explanation": "Scientific notation (e.g., `1e5` for 100000) is supported for representing large or small numbers.",
          "example": "let num = 1e5; \nconsole.log(num); \n// 100000"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `typeof` a number primitive in JavaScript is 'number'.",
          "answer": true,
          "explanation": "The `typeof` operator returns 'number' for number primitives, including integers and floats.",
          "example": "let num = 42; \nconsole.log(typeof num); \n// 'number'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Using `new Number(42)` creates a number primitive.",
          "answer": false,
          "explanation": "`new Number(42)` creates a Number object, not a primitive number. Primitive numbers are created directly (e.g., `42`).",
          "example": "let num = new Number(42); \nconsole.log(typeof num); \n// 'object'"
        }
      ]
    }
  ],
  "2": [
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the output of `try { JSON.parse('invalid'); } catch (error) { console.log(error.name); }`?",
          "options": {
            "1": "ReferenceError",
            "2": "TypeError",
            "3": "SyntaxError",
            "4": "Error"
          },
          "answer": "3",
          "explanation": "Parsing invalid JSON throws a `SyntaxError`, which is caught and logged.",
          "example": "try { JSON.parse('invalid'); } catch (error) { console.log(error.name); } // Outputs: SyntaxError"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `finally` block is useful for cleanup tasks like closing resources.",
          "answer": true,
          "explanation": "The `finally` block ensures cleanup code runs regardless of whether an error occurs.",
          "example": "try { console.log('Try'); } catch (error) {} finally { console.log('Cleanup'); } // Outputs: Try \n Cleanup"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the output of `try { let obj = null; obj.prop; } catch (error) { console.log(error.message); }`?",
          "options": {
            "1": "obj is not defined",
            "2": "Cannot read properties of null (reading 'prop')",
            "3": "TypeError",
            "4": "undefined"
          },
          "answer": "2",
          "explanation": "Accessing a property on `null` throws a `TypeError` with the specified message.",
          "example": "try { let obj = null; obj.prop; } catch (error) { console.log(error.message); } // Outputs: Cannot read properties of null (reading 'prop')"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Custom errors can be thrown using the `throw` statement.",
          "answer": true,
          "explanation": "The `throw` statement allows developers to create custom errors to signal specific conditions.",
          "example": "try { throw new Error('Invalid input'); } catch (error) { console.log(error.message); } // Outputs: Invalid input"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the best way to handle specific errors in a `try-catch` block?",
          "options": {
            "1": "Use an empty catch block",
            "2": "Check error type with instanceof",
            "3": "Ignore the error",
            "4": "Use multiple try blocks"
          },
          "answer": "2",
          "explanation": "Using `instanceof` to check error types allows handling specific errors differently.",
          "example": "try { JSON.parse('invalid'); } catch (error) { if (error instanceof SyntaxError) console.log('Invalid JSON'); } // Outputs: Invalid JSON"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "A `RangeError` is thrown when a value is out of a valid range.",
          "answer": true,
          "explanation": "A `RangeError` occurs for invalid ranges, like excessive recursion or invalid array lengths.",
          "example": "try { let arr = new Array(-1); } catch (error) { console.log(error.name); } // Outputs: RangeError"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the output of `try { throw new Error('Test'); } catch (error) { console.log('Caught'); } finally { console.log('Done'); }`?",
          "options": {
            "1": "Caught \n Done",
            "2": "Test \n Done",
            "3": "Done",
            "4": "Caught"
          },
          "answer": "1",
          "explanation": "The `catch` block handles the error, and `finally` always executes afterward.",
          "example": "try { throw new Error('Test'); } catch (error) { console.log('Caught'); } finally { console.log('Done'); } // Outputs: Caught \n Done"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Silent failures occur when errors are caught but not handled or logged.",
          "answer": true,
          "explanation": "Empty `catch` blocks or unlogged errors cause silent failures, hiding issues.",
          "example": "try { throw new Error('Test'); } catch (error) {} // Silent failure"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the output of `try { let x = '10'; x(); } catch (error) { console.log(error.name); }`?",
          "options": {
            "1": "ReferenceError",
            "2": "TypeError",
            "3": "SyntaxError",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "Calling a non-function (like a string) throws a `TypeError`.",
          "example": "try { let x = '10'; x(); } catch (error) { console.log(error.name); } // Outputs: TypeError"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `finally` block executes even if no `catch` block is present.",
          "answer": true,
          "explanation": "A `finally` block runs after the `try` block, even without a `catch` block, unless the program crashes.",
          "example": "try { console.log('Try'); } finally { console.log('Finally'); } // Outputs: Try \n Finally"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the output of `try { let arr = [1]; console.log(arr[10]); } catch (error) { console.log('Error'); }`?",
          "options": {
            "1": "Error",
            "2": "undefined",
            "3": "null",
            "4": "Nothing"
          },
          "answer": "2",
          "explanation": "Accessing an out-of-bounds array index returns `undefined`, not an error, so `catch` is skipped.",
          "example": "try { let arr = [1]; console.log(arr[10]); } catch (error) { console.log('Error'); } // Outputs: undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Custom errors should include descriptive messages for clarity.",
          "answer": true,
          "explanation": "Descriptive error messages help diagnose issues effectively.",
          "example": "try { throw new Error('Invalid input: value required'); } catch (error) { console.log(error.message); } // Outputs: Invalid input: value required"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What happens if a `try` block throws an error but there is no `catch` block?",
          "options": {
            "1": "The error is ignored",
            "2": "The `finally` block still runs",
            "3": "The program crashes immediately",
            "4": "The error is logged automatically"
          },
          "answer": "2",
          "explanation": "Without a `catch` block, the `finally` block runs, but the error propagates up, potentially crashing the program if unhandled.",
          "example": "try { throw new Error('Test'); } finally { console.log('Finally'); } // Outputs: Finally, then crashes"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `error.message` property provides a description of the error.",
          "answer": true,
          "explanation": "The `message` property contains a human-readable description of the error.",
          "example": "try { throw new Error('Test'); } catch (error) { console.log(error.message); } // Outputs: Test"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the output of `try { let obj = {}; obj.fn(); } catch (error) { console.log(error.message); }`?",
          "options": {
            "1": "obj is not defined",
            "2": "fn is not a function",
            "3": "undefined",
            "4": "TypeError"
          },
          "answer": "2",
          "explanation": "Calling a non-existent method on an object throws a `TypeError`.",
          "example": "try { let obj = {}; obj.fn(); } catch (error) { console.log(error.message); } // Outputs: fn is not a function"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What happens to an object when its reference is set to `null` and no other references exist?",
          "options": {
            "1": "It is immediately deleted",
            "2": "It is moved to the stack",
            "3": "It becomes eligible for garbage collection",
            "4": "It persists in memory"
          },
          "answer": "3",
          "explanation": "Setting a reference to `null` makes the heap object unreachable, eligible for garbage collection via mark-and-sweep.",
          "example": "let obj = { a: 1 }; obj = null; // Object eligible for collection."
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "A closure retains heap memory even after the outer function’s execution ends.",
          "answer": true,
          "explanation": "Closures retain the outer function’s scope (including variables) in the heap if the inner function references them.",
          "example": "function outer() { let x = 1; return () => x; } let fn = outer(); // x retained in heap."
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the output of `function outer() { let x = { a: 1 }; return () => x.a; } let fn = outer(); fn = null; console.log(typeof fn);`?",
          "options": {
            "1": "function",
            "2": "object",
            "3": "null",
            "4": "undefined"
          },
          "answer": "3",
          "explanation": "Setting `fn = null` removes the closure reference, making the heap data eligible for garbage collection. `typeof fn` returns 'null'.",
          "example": "function outer() { let x = { a: 1 }; return () => x.a; } let fn = outer(); fn = null; console.log(typeof fn); // Outputs: null"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The mark-and-sweep algorithm can handle cyclic references.",
          "answer": true,
          "explanation": "Mark-and-sweep identifies unreachable objects, including cyclic references, unlike older reference-counting systems.",
          "example": "let obj1 = {}; let obj2 = {}; obj1.ref = obj2; obj2.ref = obj1; obj1 = null; obj2 = null; // Cycle collected."
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "Which of the following can cause a memory leak?",
          "options": {
            "1": "Setting an object to null",
            "2": "Using let for variable declarations",
            "3": "Unremoved event listeners",
            "4": "Primitive assignments"
          },
          "answer": "3",
          "explanation": "Unremoved event listeners retain heap references, causing memory leaks. Other options don’t contribute to leaks.",
          "example": "let btn = document.querySelector('button'); btn.addEventListener('click', () => console.log('Click')); // Leak if not removed."
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Global variables can prevent garbage collection if not cleared.",
          "answer": true,
          "explanation": "Global variables persist in the heap, preventing garbage collection unless explicitly cleared or reassigned.",
          "example": "globalVar = { a: 1 }; // Persists until cleared."
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What happens to the stack when a function returns?",
          "options": {
            "1": "It is moved to the heap",
            "2": "Its frame is popped",
            "3": "It is garbage-collected",
            "4": "It remains unchanged"
          },
          "answer": "2",
          "explanation": "When a function returns, its stack frame is popped, freeing local variables.",
          "example": "function test() { let x = 1; } test(); // Stack frame popped."
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Assigning a new object to a variable creates a new heap allocation.",
          "answer": true,
          "explanation": "Each new object allocation creates a new memory section in the heap, with the stack reference updated.",
          "example": "let obj = { a: 1 }; obj = { b: 2 }; // New heap allocation for { b: 2 }."
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the output of `let arr = [1, 2]; let arr2 = arr; arr = [3, 4]; console.log(arr2);`?",
          "options": {
            "1": "[1, 2]",
            "2": "[3, 4]",
            "3": "null",
            "4": "undefined"
          },
          "answer": "1",
          "explanation": "Reassigning `arr` creates a new array in the heap; `arr2` still references the original array.",
          "example": "let arr = [1, 2]; let arr2 = arr; arr = [3, 4]; console.log(arr2); // Outputs: [1, 2]"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "A timer like `setInterval` can cause a memory leak if not cleared.",
          "answer": true,
          "explanation": "Uncleared timers retain callbacks in the heap, causing memory leaks.",
          "example": "let timer = setInterval(() => console.log('Run'), 1000); // Leak if not cleared."
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "Which phase of mark-and-sweep identifies reachable objects?",
          "options": {
            "1": "Sweep phase",
            "2": "Mark phase",
            "3": "Allocation phase",
            "4": "Deallocation phase"
          },
          "answer": "2",
          "explanation": "The mark phase traverses from roots to mark reachable objects; the sweep phase deallocates unmarked ones.",
          "example": "let obj = { a: 1 }; obj = null; // Mark phase skips obj, sweep phase collects it."
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Class instances are stored in the heap.",
          "answer": true,
          "explanation": "Class instances are objects and are stored in the heap, with references in the stack.",
          "example": "class Person { constructor(name) { this.name = name; } } let p = new Person('Luiz'); // Instance in heap."
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the output of `function test() { let x = 10; } test(); console.log(typeof x);`?",
          "options": {
            "1": "number",
            "2": "undefined",
            "3": "ReferenceError",
            "4": "null"
          },
          "answer": "3",
          "explanation": "Local variable `x` is in the function’s stack frame, which is popped after execution, causing a ReferenceError.",
          "example": "function test() { let x = 10; } test(); console.log(typeof x); // ReferenceError"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Setting a variable to `null` helps the garbage collector by removing references.",
          "answer": true,
          "explanation": "Setting a variable to `null` removes its reference, making heap objects eligible for collection if no other references exist.",
          "example": "let arr = [1, 2]; arr = null; // Array eligible for collection."
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What can prevent an object from being garbage-collected?",
          "options": {
            "1": "Setting it to null",
            "2": "A closure referencing it",
            "3": "Using const for declaration",
            "4": "Primitive assignment"
          },
          "answer": "2",
          "explanation": "A closure retains referenced objects in the heap, preventing garbage collection.",
          "example": "function outer() { let obj = {}; return () => obj; } let fn = outer(); // obj retained."
        }
      ]
    },
    {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A closure retains access to an outer function’s variables even after the outer function has finished executing.",
        "answer": true,
        "explanation": "A closure allows an inner function to maintain a reference to its outer function’s variables, keeping them in memory after the outer function returns.",
        "example": "function outer() { let x = 1; return function() { console.log(x); }; } let fn = outer(); fn(); // Outputs: 1"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `function outer() { let x = 5; return function() { x++; return x; }; } let fn = outer(); console.log(fn()); console.log(fn());`?",
        "options": {
          "1": "5, 5",
          "2": "6, 7",
          "3": "5, 6",
          "4": "ReferenceError"
        },
        "answer": "2",
        "explanation": "The inner function forms a closure over `x`, incrementing and returning it each time it is called, so the values increase.",
        "example": "function outer() { let x = 5; return function() { x++; return x; }; } let fn = outer(); console.log(fn()); console.log(fn()); // Outputs: 6, 7"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "Variables declared with `var` in a block scope are accessible outside the block.",
        "answer": true,
        "explanation": "Unlike `let` or `const`, `var` is not block-scoped; it is function-scoped or global, so it is accessible outside a block.",
        "example": "if (true) { var x = 1; } console.log(x); // Outputs: 1"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let x = 'global'; function outer() { let x = 'outer'; function inner() { console.log(x); } inner(); } outer();`?",
        "options": {
          "1": "global",
          "2": "outer",
          "3": "ReferenceError",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The inner function accesses `x` from its immediate outer scope (`outer` function), which shadows the global `x`.",
        "example": "let x = 'global'; function outer() { let x = 'outer'; function inner() { console.log(x); } inner(); } outer(); // Outputs: outer"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A closure can modify the value of a variable in its outer scope if the variable is mutable.",
        "answer": true,
        "explanation": "Closures can modify outer scope variables declared with `let` or `var`, as they maintain a reference to those variables.",
        "example": "function outer() { let x = 1; return function() { x++; return x; }; } let fn = outer(); console.log(fn()); // Outputs: 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `function createCounter() { let count = 0; return { increment: function() { count++; }, getCount: function() { return count; } }; } let counter = createCounter(); counter.increment(); console.log(counter.getCount());`?",
        "options": {
          "1": "0",
          "2": "1",
          "3": "ReferenceError",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The module pattern creates a closure, allowing `increment` to modify `count` and `getCount` to access it.",
        "example": "function createCounter() { let count = 0; return { increment: function() { count++; }, getCount: function() { return count; } }; } let counter = createCounter(); counter.increment(); console.log(counter.getCount()); // Outputs: 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A variable declared with `const` in a closure cannot be reassigned but its properties can be modified if it’s an object.",
        "answer": true,
        "explanation": "A `const` variable cannot be reassigned, but if it holds an object, the object’s properties can be modified within a closure.",
        "example": "function outer() { const obj = { x: 1 }; return function() { obj.x++; return obj.x; }; } let fn = outer(); console.log(fn()); // Outputs: 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `function outer() { let x = 10; function inner() { let x = 20; console.log(x); } inner(); } outer();`?",
        "options": {
          "1": "10",
          "2": "20",
          "3": "ReferenceError",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The inner function declares its own `x`, which shadows the outer `x`, so it logs the local value.",
        "example": "function outer() { let x = 10; function inner() { let x = 20; console.log(x); } inner(); } outer(); // Outputs: 20"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A closure is automatically garbage collected when no references to the inner function remain.",
        "answer": true,
        "explanation": "When all references to a closure are removed (e.g., set to `null`), the JavaScript garbage collector can reclaim the memory used by the closure and its captured variables.",
        "example": "function outer() { let x = 1; return function() { console.log(x); }; } let fn = outer(); fn = null; // Closure is eligible for garbage collection"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `function createAdder(n) { return function(x) { return x + n; }; } let addFive = createAdder(5); console.log(addFive(3));`?",
        "options": {
          "1": "5",
          "2": "3",
          "3": "8",
          "4": "ReferenceError"
        },
        "answer": "3",
        "explanation": "The inner function forms a closure over `n`, adding it to the input `x`. Here, `n` is 5, so `5 + 3 = 8`.",
        "example": "function createAdder(n) { return function(x) { return x + n; }; } let addFive = createAdder(5); console.log(addFive(3)); // Outputs: 8"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A function scope cannot access variables declared in a block scope within the same function unless the block scope is its outer scope.",
        "answer": true,
        "explanation": "A function scope can only access block-scoped variables if they are in its outer scope, not in sibling or unrelated blocks.",
        "example": "function test() { if (true) { let x = 1; } console.log(x); } test(); // ReferenceError: x is not defined"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let global = 'global'; function outer() { let global = 'outer'; return function() { console.log(global); }; } let fn = outer(); fn();`?",
        "options": {
          "1": "global",
          "2": "outer",
          "3": "ReferenceError",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The inner function’s closure captures the `global` variable from the `outer` function, which shadows the global scope variable.",
        "example": "let global = 'global'; function outer() { let global = 'outer'; return function() { console.log(global); }; } let fn = outer(); fn(); // Outputs: outer"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A closure can be created by returning an object with methods that access private variables.",
        "answer": true,
        "explanation": "The module pattern uses a closure to return an object with methods that access private variables, encapsulating data.",
        "example": "function module() { let x = 1; return { getX: function() { return x; } }; } let m = module(); console.log(m.getX()); // Outputs: 1"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `function outer() { let x = 0; return function() { return ++x; }; } let fn1 = outer(); let fn2 = outer(); console.log(fn1()); console.log(fn2());`?",
        "options": {
          "1": "1, 1",
          "2": "1, 2",
          "3": "2, 2",
          "4": "ReferenceError"
        },
        "answer": "1",
        "explanation": "Each call to `outer` creates a new closure with its own `x`. Thus, `fn1` and `fn2` have separate `x` variables, both starting at 0.",
        "example": "function outer() { let x = 0; return function() { return ++x; }; } let fn1 = outer(); let fn2 = outer(); console.log(fn1()); console.log(fn2()); // Outputs: 1, 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "Variables declared with `let` in a function scope are not hoisted to the top of the function.",
        "answer": true,
        "explanation": "Unlike `var`, variables declared with `let` are not hoisted to the top of their scope; they are only accessible after declaration.",
        "example": "function test() { console.log(x); let x = 1; } test(); // ReferenceError: Cannot access 'x' before initialization"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A `for...in` loop iterates over all properties of an object, including inherited ones.",
        "answer": true,
        "explanation": "A `for...in` loop iterates over all enumerable properties of an object, including those inherited from its prototype chain.",
        "example": "let obj = { a: 1 }; Object.prototype.b = 2; for (let key in obj) { console.log(key); } // Outputs: a, b"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2, 3]; for (let x of arr) { console.log(x * 2); }`?",
        "options": {
          "1": "1, 2, 3",
          "2": "2, 4, 6",
          "3": "Nothing",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "The `for...of` loop iterates over the values of the array, and each value is multiplied by 2 before being logged.",
        "example": "let arr = [1, 2, 3]; for (let x of arr) { console.log(x * 2); } // Outputs: 2, 4, 6"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "Using `continue` in a `switch` statement is valid and skips to the next case.",
        "answer": false,
        "explanation": "`continue` is used in loops to skip to the next iteration, not in `switch` statements. Using it in a `switch` causes a syntax error unless the `switch` is inside a loop.",
        "example": "let x = 1; switch (x) { case 1: continue; } // SyntaxError"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let i = 0; while (i < 3) { if (i === 1) { i++; continue; } console.log(i); i++; }`?",
        "options": {
          "1": "0, 2",
          "2": "0, 1, 2",
          "3": "1, 2",
          "4": "0"
        },
        "answer": "1",
        "explanation": "The `while` loop logs `i` and increments it. When `i` is 1, `continue` skips the rest of the loop body, so 1 is not logged, and the loop continues with `i = 2`.",
        "example": "let i = 0; while (i < 3) { if (i === 1) { i++; continue; } console.log(i); i++; } // Outputs: 0, 2"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "The `&&` operator short-circuits and stops evaluating as soon as it encounters a falsy value.",
        "answer": true,
        "explanation": "The `&&` operator evaluates expressions from left to right and stops at the first falsy value, returning it, or returns the last value if all are truthy.",
        "example": "let x = 0; console.log(x && 'test'); // Outputs: 0"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let obj = {a: 1, b: 2}; for (let key in obj) { console.log(key); }`?",
        "options": {
          "1": "1, 2",
          "2": "a, b",
          "3": "a: 1, b: 2",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "The `for...in` loop iterates over the enumerable property names of an object, not their values.",
        "example": "let obj = {a: 1, b: 2}; for (let key in obj) { console.log(key); } // Outputs: a, b"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A `try...catch` block can be used to handle errors within a loop.",
        "answer": true,
        "explanation": "A `try...catch` block can catch errors thrown during loop execution, allowing the program to continue or handle the error gracefully.",
        "example": "try { for (let i = 0; i < 2; i++) { if (i === 1) throw new Error('Stop'); console.log(i); } } catch (e) { console.log(e.message); } // Outputs: 0, Stop"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let x = 5; console.log(x > 10 ? 'High' : x > 0 ? 'Positive' : 'Negative');`?",
        "options": {
          "1": "High",
          "2": "Positive",
          "3": "Negative",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "The nested ternary operator evaluates `x > 10` (false), then `x > 0` (true), returning 'Positive'.",
        "example": "let x = 5; console.log(x > 10 ? 'High' : x > 0 ? 'Positive' : 'Negative'); // Outputs: Positive"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "The `break` statement can exit a nested loop if used with a label.",
        "answer": true,
        "explanation": "A labeled `break` statement can exit a specific outer loop in a nested loop structure.",
        "example": "outer: for (let i = 0; i < 2; i++) { for (let j = 0; j < 2; j++) { if (j === 1) break outer; console.log(j); } } // Outputs: 0"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let i = 0; do { console.log(i); i++; } while (i < 0);`?",
        "options": {
          "1": "0",
          "2": "Nothing",
          "3": "0, 1",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `do...while` loop executes once before checking the condition. Since `i < 0` is `false` after the first iteration, only `0` is logged.",
        "example": "let i = 0; do { console.log(i); i++; } while (i < 0); // Outputs: 0"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "Variables declared with `let` inside an `if` block are accessible outside the block.",
        "answer": false,
        "explanation": "Variables declared with `let` inside a block (like an `if` block) are block-scoped and not accessible outside it.",
        "example": "if (true) { let x = 1; } console.log(x); // ReferenceError: x is not defined"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let x = true; x && console.log('Run');`?",
        "options": {
          "1": "Run",
          "2": "true",
          "3": "Nothing",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `&&` operator evaluates to the last value if all are truthy. Since `x` is `true`, the `console.log('Run')` expression is evaluated, logging 'Run'.",
        "example": "let x = true; x && console.log('Run'); // Outputs: Run"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "The `for...of` loop can iterate over the characters of a string.",
        "answer": true,
        "explanation": "The `for...of` loop iterates over iterable objects, such as strings, yielding each character.",
        "example": "for (let char of 'hi') { console.log(char); } // Outputs: h, i"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let x = 0; if (x) { console.log('Truthy'); } else { console.log('Falsy'); }`?",
        "options": {
          "1": "Truthy",
          "2": "Falsy",
          "3": "Nothing",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "In JavaScript, `0` is a falsy value, so the `else` block executes.",
        "example": "let x = 0; if (x) { console.log('Truthy'); } else { console.log('Falsy'); } // Outputs: Falsy"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A `switch` statement can use expressions as case values.",
        "answer": false,
        "explanation": "A `switch` statement compares the switch expression to case values using strict equality (`===`). Case values must be constants, not expressions.",
        "example": "let x = 1; switch (x) { case 1 + 0: console.log('Match'); } // Outputs: Match, but case must be a constant like `1`"
      }
    ]
  },
    {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A named function expression is hoisted like a function declaration.",
        "answer": false,
        "explanation": "Named function expressions are not hoisted; only the variable declaration is hoisted (if using `var`), and the function assignment happens at runtime.",
        "example": "console.log(fn()); const fn = function named() { return 'Hi'; }; // TypeError: fn is not a function"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A closure allows an inner function to access variables from its outer function even after the outer function has finished executing.",
        "answer": true,
        "explanation": "Closures maintain access to the outer function’s scope, keeping variables alive in memory for the inner function.",
        "example": "function outer() { let x = 10; return () => x++; } const fn = outer(); console.log(fn()); // 10, console.log(fn()); // 11"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What does `const greet = function() { console.log(this.name); }.bind({ name: 'Alice' }); greet();` output?",
        "options": {
          "1": "Alice",
          "2": "undefined",
          "3": "Error",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The `bind` method creates a new function with `this` set to the provided object `{ name: 'Alice' }`, so `greet()` logs 'Alice'.",
        "example": "const greet = function() { console.log(this.name); }.bind({ name: 'Alice' }); greet(); // Alice"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "Functions can have properties added to them dynamically.",
        "answer": true,
        "explanation": "Since functions are objects, properties can be added to them dynamically, just like any other object.",
        "example": "function fn() {} fn.version = '1.0'; console.log(fn.version); // 1.0"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is a valid way to create a function using the constructor function pattern?",
        "options": {
          "1": "function Person(name) { this.name = name; }",
          "2": "() => { this.name = name; }",
          "3": "const Person = name => name;",
          "4": "(function Person(name) {})()"
        },
        "answer": "1",
        "explanation": "Constructor functions are typically defined using function declarations or expressions and use `this` to set properties on new instances.",
        "example": "function Person(name) { this.name = name; } const p = new Person('Alice'); console.log(p.name); // Alice"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "The `arguments` object is available in arrow functions.",
        "answer": false,
        "explanation": "Arrow functions do not have their own `arguments` object; they inherit it from the enclosing scope.",
        "example": "const fn = () => console.log(arguments); fn(); // ReferenceError: arguments is not defined"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What does `function sum() { let total = 0; for (let x of arguments) total += x; return total; } console.log(sum(1, 2, 3));` return?",
        "options": {
          "1": "6",
          "2": "undefined",
          "3": "[1, 2, 3]",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `arguments` object contains all passed arguments, and the function sums them to return 6.",
        "example": "function sum() { let total = 0; for (let x of arguments) total += x; return total; } console.log(sum(1, 2, 3)); // 6"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A function can use default parameters to provide fallback values.",
        "answer": true,
        "explanation": "Default parameters allow functions to assign fallback values to parameters if no argument is provided.",
        "example": "function greet(name = 'Guest') { console.log(`Hello, ${name}!`); } greet(); // Hello, Guest!"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What does `const module = (function() { let x = 1; return { get: () => x }; })(); console.log(module.get());` return?",
        "options": {
          "1": "1",
          "2": "undefined",
          "3": "Error",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The IIFE creates a module with a private variable `x` and returns an object with a `get` method that accesses `x` via a closure.",
        "example": "const module = (function() { let x = 1; return { get: () => x }; })(); console.log(module.get()); // 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "The `call()` method can set the `this` context of a function.",
        "answer": true,
        "explanation": "The `call()` method invokes a function with a specified `this` context and individual arguments.",
        "example": "function greet() { console.log(this.name); } greet.call({ name: 'Alice' }); // Alice"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What does `function greet(name = 'Guest') { return `Hello, ${name}!`; } console.log(greet());` return?",
        "options": {
          "1": "Hello, Guest!",
          "2": "Hello, undefined!",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The function uses a default parameter `name = 'Guest'`, so calling it without arguments returns 'Hello, Guest!'.",
        "example": "function greet(name = 'Guest') { return `Hello, ${name}!`; } console.log(greet()); // Hello, Guest!"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A function’s properties can be deleted using the `delete` operator.",
        "answer": true,
        "explanation": "Since functions are objects, their properties can be deleted using the `delete` operator.",
        "example": "function fn() {} fn.prop = 'test'; delete fn.prop; console.log(fn.prop); // undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is a correct way to use a rest parameter in a function?",
        "options": {
          "1": "function sum(...numbers) { return numbers.reduce((a, b) => a + b, 0); }",
          "2": "function sum(numbers...) { return numbers.reduce((a, b) => a + b, 0); }",
          "3": "function sum(...numbers) { return arguments.reduce((a, b) => a + b, 0); }",
          "4": "function sum(numbers) { return numbers.reduce(...a, b); }"
        },
        "answer": "1",
        "explanation": "Rest parameters use the `...` syntax to collect all arguments into an array, which can be processed (e.g., with `reduce`).",
        "example": "function sum(...numbers) { return numbers.reduce((a, b) => a + b, 0); } console.log(sum(1, 2, 3)); // 6"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A higher-order function can return another function.",
        "answer": true,
        "explanation": "Higher-order functions can accept functions as arguments and/or return functions, enabling patterns like closures.",
        "example": "function createAdder(x) { return y => x + y; } const add5 = createAdder(5); console.log(add5(3)); // 8"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What does `const obj = {}; (function(o) { o.fn = () => console.log('Hi'); })(obj); obj.fn();` output?",
        "options": {
          "1": "Hi",
          "2": "undefined",
          "3": "Error",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The IIFE adds a method `fn` to the `obj` object, which logs 'Hi' when called.",
        "example": "const obj = {}; (function(o) { o.fn = () => console.log('Hi'); })(obj); obj.fn(); // Hi"
      }
    ]
  },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `Object.entries()` method returns an array of key-value pair arrays for an object’s enumerable properties.",
          "answer": true,
          "explanation": "`Object.entries()` returns an array of `[key, value]` arrays for the object’s own enumerable properties.",
          "example": "let obj = { a: 1, b: 2 }; console.log(Object.entries(obj)); // [['a', 1], ['b', 2]]"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the result of `let str = 'hello'; console.log(str.includes('ll'));`?",
          "options": {
            "1": "true",
            "2": "false",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "The `includes()` method checks if a substring exists in the string, returning `true` for 'll' in 'hello'.",
          "example": "let str = 'hello'; console.log(str.includes('ll')); // true"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `parseInt()` function can parse a string and return an integer, ignoring decimal parts.",
          "answer": true,
          "explanation": "`parseInt()` converts a string to an integer, stopping at the decimal point and ignoring non-numeric characters after a valid number.",
          "example": "console.log(parseInt('123.45')); // 123"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the result of `console.log(0 || 'hello');`?",
          "options": {
            "1": "0",
            "2": "'hello'",
            "3": "false",
            "4": "undefined"
          },
          "answer": "2",
          "explanation": "The `||` operator returns the first truthy value; `0` is falsy, so it returns `'hello'`, which is truthy.",
          "example": "console.log(0 || 'hello'); // 'hello'"
        }
      ]
    },
    {
  "type": 2,
  "level": "medium",
  "question": [
    {
      "question": "Which of the following correctly lists all primary methods for creating an object in JavaScript along with an example for each?",
      "options": {
        "1": "Object Literal: `let obj = { name: 'Luiz' };`, Object Constructor: `let obj = new Object(); obj.name = 'Luiz';`, Object.create: `let obj = Object.create({ name: 'Luiz' });`, Factory Function: `function createObj() { return { name: 'Luiz' }; }`, Class Syntax: `class Person { constructor(name) { this.name = name; } } let obj = new Person('Luiz');`",
        "2": "Object Literal: `let obj = [];`, Object Constructor: `let obj = new Object();`, Object.create: `let obj = Object.create(null);`, Factory Function: `function createObj() { return new Object(); }`, Class Syntax: `class Person { name = 'Luiz'; }`",
        "3": "Object Literal: `let obj = { name: 'Luiz' };`, Object Constructor: `let obj = Object();`, Object.create: `let obj = Object.create({});`, Factory Function: `function createObj() { return { name: 'Luiz' }; }`, Class Syntax: `class Person { constructor() { name: 'Luiz'; } }`",
        "4": "Object Literal: `let obj = new Object();`, Object Constructor: `let obj = {};`, Object.create: `let obj = Object.create(null); obj.name = 'Luiz';`, Factory Function: `function createObj() { this.name = 'Luiz'; }`, Class Syntax: `class Person { constructor(name) { this.name = name; } }`"
      },
      "answer": "1",
      "explanation": "The primary methods for creating objects are: Object Literal (`{}`), Object Constructor (`new Object()`), Object.create (`Object.create(proto)`), Factory Function (returns an object), and Class Syntax (`class`). Option 1 is correct. Common errors in other options include: Option 2 uses `[]` for Object Literal, Option 3 uses invalid `Object()` syntax, and Option 4 misuses Object Literal and Factory Function syntax.",
      "example": "let obj1 = { name: 'Luiz' }; // Object Literal\nlet obj2 = new Object(); obj2.name = 'Luiz'; // Object Constructor\nlet obj3 = Object.create({ name: 'Luiz' }); // Object.create\nfunction createObj() { return { name: 'Luiz' }; } let obj4 = createObj(); // Factory Function\nclass Person { constructor(name) { this.name = name; } } let obj5 = new Person('Luiz'); // Class Syntax\nconsole.log(obj1.name, obj2.name, obj3.name, obj4.name, obj5.name); \n// 'Luiz', 'Luiz', 'Luiz', 'Luiz', 'Luiz'"
    }
  ]
},
     {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "Properties defined in an object literal are automatically enumerable, making them appear in `for...in` loops.",
        "answer": true,
        "explanation": "Object literal properties are enumerable by default, so they are included in `for...in` loops unless explicitly set to `enumerable: false`.",
        "example": "let obj = { name: 'Luiz' }; for (let key in obj) { console.log(key); } \n// 'name'"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A custom constructor function using `this` allows creating multiple objects with shared methods via the prototype.",
        "answer": true,
        "explanation": "Constructor functions use `this` to assign properties, and methods added to the constructor’s prototype are shared across instances.",
        "example": "function Person(name) { this.name = name; } Person.prototype.greet = function() { return 'Hi'; }; let p = new Person('Luiz'); console.log(p.greet()); \n// 'Hi'"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "`Object.create(null)` creates an object with no prototype, preventing inheritance of `Object.prototype` methods.",
        "answer": true,
        "explanation": "`Object.create(null)` creates an object with no prototype, so it does not inherit methods like `toString()` from `Object.prototype`.",
        "example": "let obj = Object.create(null); console.log(obj.toString); \n// undefined"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "Factory Functions can create private variables using closures, unlike Class Syntax.",
        "answer": true,
        "explanation": "Factory Functions can encapsulate private data via closures, while Class Syntax exposes properties through `this`, making them public.",
        "example": "function createObj() { let secret = 'hidden'; return { getSecret: () => secret }; } let obj = createObj(); console.log(obj.getSecret()); \n// 'hidden'"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "The `extends` keyword in Class Syntax allows a subclass to inherit methods from a parent class.",
        "answer": true,
        "explanation": "The `extends` keyword enables a subclass to inherit properties and methods from a parent class via the prototype chain.",
        "example": "class Parent { greet() { return 'Hi'; } } class Child extends Parent {} let c = new Child(); console.log(c.greet()); \n// 'Hi'"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `function Person(name) { this.name = name; } let p1 = new Person('Luiz'); let p2 = new Person('Marta'); console.log(p1.name, p2.name);`?",
        "options": {
          "1": "'Luiz', 'Marta'",
          "2": "'Marta', 'Luiz'",
          "3": "undefined, undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The constructor function `Person` assigns the `name` property to each instance, so `p1` and `p2` have their respective names.",
        "example": "function Person(name) { this.name = name; } let p1 = new Person('Luiz'); let p2 = new Person('Marta'); console.log(p1.name, p2.name); \n// 'Luiz', 'Marta'"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What does `let proto = { greet: () => 'Hi' }; let obj = Object.create(proto); console.log(Object.getPrototypeOf(obj) === proto);` return?",
        "options": {
          "1": "true",
          "2": "false",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`Object.create(proto)` sets `proto` as the prototype of `obj`, so `Object.getPrototypeOf(obj)` returns `proto`.",
        "example": "let proto = { greet: () => 'Hi' }; let obj = Object.create(proto); console.log(Object.getPrototypeOf(obj) === proto); \n// true"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `function createObj() { return { name: 'Luiz', getName: function() { return this.name; } }; } let obj = createObj(); console.log(obj.getName());`?",
        "options": {
          "1": "'Luiz'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The Factory Function returns an object with a `getName` method that uses `this` to access the `name` property, returning 'Luiz'.",
        "example": "function createObj() { return { name: 'Luiz', getName: function() { return this.name; } }; } let obj = createObj(); console.log(obj.getName()); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let obj = Object.create({ name: 'Luiz' }); obj.name = 'Marta'; console.log(obj.name, Object.getPrototypeOf(obj).name);`?",
        "options": {
          "1": "'Marta', 'Luiz'",
          "2": "'Luiz', 'Marta'",
          "3": "'Marta', undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Assigning `obj.name = 'Marta'` creates an own property, shadowing the prototype’s `name`. The prototype’s `name` remains 'Luiz'.",
        "example": "let obj = Object.create({ name: 'Luiz' }); obj.name = 'Marta'; console.log(obj.name, Object.getPrototypeOf(obj).name); \n// 'Marta', 'Luiz'"
      }
    ]
  },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Assigning an object to a new variable creates a reference to the same object in memory.",
          "answer": true,
          "explanation": "Objects are reference types, so assigning an object to a new variable copies the reference, not the object itself, affecting the original when modified.",
          "example": "let obj = { a: 1 }; \nlet copy = obj; \ncopy.a = 2; \nconsole.log(obj.a); \n// 2"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `Object.keys()` method modifies the original object.",
          "answer": false,
          "explanation": "`Object.keys()` is non-mutative, returning a new array of the object's enumerable property names without altering the object.",
          "example": "let obj = { a: 1, b: 2 }; \nconsole.log(Object.keys(obj)); \nconsole.log(obj); \n// ['a', 'b'] { a: 1, b: 2 }"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `Object.seal()` method prevents modifications to existing object properties.",
          "answer": false,
          "explanation": "`Object.seal()` prevents adding or deleting properties but allows modifying the values of existing properties.",
          "example": "let obj = { a: 1 }; \nObject.seal(obj); \nobj.a = 2; \nconsole.log(obj.a); \n// 2"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `delete` operator returns `true` when a non-existent property is deleted.",
          "answer": true,
          "explanation": "The `delete` operator returns `true` when attempting to delete a non-existent property, as the operation is considered successful.",
          "example": "let obj = { a: 1 }; \nconsole.log(delete obj.b); \n// true"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `Object.create()` method allows creating objects with a specified prototype.",
          "answer": true,
          "explanation": "`Object.create()` creates a new object with the specified prototype, allowing inheritance of properties and methods.",
          "example": "let proto = { greet: () => 'Hi' }; \nlet obj = Object.create(proto); \nconsole.log(obj.greet()); \n// 'Hi'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Factory functions use prototype inheritance to share methods between objects.",
          "answer": false,
          "explanation": "Factory functions return new objects without using prototypes, creating separate method copies for each object.",
          "example": "function create() { return { greet: () => 'Hi' }; \n} let obj1 = create(); \nlet obj2 = create(); \nconsole.log(obj1.greet === obj2.greet); \n// false"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The spread operator (`...`) creates a deep copy of an object.",
          "answer": false,
          "explanation": "The spread operator creates a shallow copy, copying only top-level properties; \nnested objects remain referenced.",
          "example": "let obj = { a: { b: 1 } }; \nlet copy = { ...obj }; \ncopy.a.b = 2; \nconsole.log(obj.a.b); \n// 2"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the result of `let obj = { a: 1, b: 2 }; \nconsole.log(Object.keys(obj));`?",
          "options": {
            "1": "['a', 'b']",
            "2": "[1, 2]",
            "3": "{ a: 1, b: 2 }",
            "4": "undefined"
          },
          "answer": "1",
          "explanation": "`Object.keys()` returns an array of the object's enumerable property names, in this case, `['a', 'b']`.",
          "example": "let obj = { a: 1, b: 2 }; \nconsole.log(Object.keys(obj)); \n// ['a', 'b']"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What does `let obj = { name: 'Luiz' }; \ndelete obj.name; \nconsole.log(obj);` return?",
          "options": {
            "1": "{ name: 'Luiz' }",
            "2": "{}",
            "3": "undefined",
            "4": "null"
          },
          "answer": "2",
          "explanation": "The `delete` operator removes the `name` property, leaving an empty object `{}`.",
          "example": "let obj = { name: 'Luiz' }; \ndelete obj.name; \nconsole.log(obj); \n// {}"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the result of `let obj = Object.create({ name: 'Luiz' }); \nconsole.log(obj.name);`?",
          "options": {
            "1": "'Luiz'",
            "2": "undefined",
            "3": "null",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "`Object.create()` sets the prototype to the specified object, so `obj.name` accesses the inherited `name` property.",
          "example": "let obj = Object.create({ name: 'Luiz' }); \nconsole.log(obj.name); \n// 'Luiz'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `concat()` method creates a new array without modifying the original arrays.",
          "answer": true,
          "explanation": "`concat()` returns a new array combining the original array with additional arrays or values, leaving the original unchanged.",
          "example": "let arr1 = [1, 2]; let arr2 = arr1.concat([3]); console.log(arr1, arr2); // [1, 2], [1, 2, 3]"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.slice()` method modifies the original array.",
          "answer": false,
          "explanation": "`.slice()` is non-mutative, returning a new array with the selected elements without altering the original.",
          "example": "let arr = [1, 2, 3]; \nconsole.log(arr.slice(0, 2)); \nconsole.log(arr); \n// [1, 2] [1, 2, 3]"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.splice()` method can be used to add elements to an array without removing any.",
          "answer": true,
          "explanation": "`.splice()` can add elements by specifying a delete count of 0, inserting new elements at the given index.",
          "example": "let arr = [1, 2]; \narr.splice(1, 0, 'a'); \nconsole.log(arr); \n// [1, 'a', 2]"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.at()` method supports negative indices to access elements from the end of an array.",
          "answer": true,
          "explanation": "The `.at()` method, introduced in ES2022, allows negative indices to access elements from the array's end.",
          "example": "let arr = [1, 2, 3]; \nconsole.log(arr.at(-1)); // 3"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.forEach()` method always returns a new array with the results of the callback function.",
          "answer": false,
          "explanation": "`.forEach()` executes a callback for each element and returns `undefined`, not a new array.",
          "example": "let arr = [1, 2]; console.log(arr.forEach(x => x * 2)); // undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.unshift()` method adds elements to the beginning of an array and returns the new length.",
          "answer": true,
          "explanation": "`.unshift()` adds elements to the start of an array and returns the new `.length` of the array.",
          "example": "let arr = [1, 2]; console.log(arr.unshift(0)); // 3"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.shift()` method removes the last element of an array.",
          "answer": false,
          "explanation": "`.shift()` removes the first element of an array, not the last (which is done by `.pop()`).",
          "example": "let arr = [1, 2, 3]; console.log(arr.shift()); // 1"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What does `let arr = [1, 2, 3]; console.log(arr.shift());` return?",
          "options": {
            "1": "1",
            "2": "3",
            "3": "[2, 3]",
            "4": "undefined"
          },
          "answer": "1",
          "explanation": "`.shift()` removes and returns the first element of the array, which is 1.",
          "example": "let arr = [1, 2, 3]; console.log(arr.shift()); console.log(arr); // 1 [2, 3]"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The result of `0.1 + 0.2` in JavaScript is exactly `0.3`.",
          "answer": false,
          "explanation": "Due to floating-point precision issues in JavaScript, `0.1 + 0.2` results in `0.30000000000000004`, not exactly `0.3`.",
          "example": "console.log(0.1 + 0.2); // 0.30000000000000004"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "`Number.isNaN('42')` returns `true`.",
          "answer": false,
          "explanation": "`Number.isNaN()` only returns `true` for the `NaN` value; `'42'` is a string and returns `false`.",
          "example": "console.log(Number.isNaN('42')); // false"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Numbers beyond `Number.MAX_SAFE_INTEGER` may lose precision in JavaScript.",
          "answer": true,
          "explanation": "Numbers larger than `Number.MAX_SAFE_INTEGER` (2^53 - 1) may lose precision due to JavaScript's 64-bit floating-point representation.",
          "example": "console.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2); // true (loss of precision)"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Performing arithmetic with `undefined` results in `0`.",
          "answer": false,
          "explanation": "Arithmetic operations with `undefined` coerce it to `NaN`, resulting in `NaN`, not `0`.",
          "example": "console.log(undefined + 1); // NaN"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.toFixed()` method returns a number, not a string.",
          "answer": false,
          "explanation": "`.toFixed()` returns a string representing the number with a specified number of decimal places.",
          "example": "let num = 3.14159; console.log(num.toFixed(2)); console.log(typeof num.toFixed(2)); // '3.14' 'string'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The expression true && false evaluates to true.",
          "answer": false,
          "explanation": "The `&&` operator returns `false` if any operand is `false`, so `true && false` is `false`.",
          "example": "console.log(true && false); // false"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "An empty string ('') is considered a truthy value.",
          "answer": false,
          "explanation": "An empty string is a falsy value in JavaScript, evaluating to `false` in a boolean context.",
          "example": "console.log(Boolean('')); // false"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The Boolean() function and !! operator always produce the same result when converting a value.",
          "answer": true,
          "explanation": "Both `Boolean()` and the double NOT operator (`!!`) convert a value to a boolean, producing identical results.",
          "example": "let val = 'hello'; console.log(Boolean(val), !!val); // true true"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The value null is considered falsy in a Boolean context.",
          "answer": true,
          "explanation": "`null` is a falsy value, evaluating to `false` in a boolean context.",
          "example": "console.log(Boolean(null)); // false"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Using new Boolean(false) creates a primitive Boolean value.",
          "answer": false,
          "explanation": "`new Boolean(false)` creates a Boolean object, not a primitive boolean value.",
          "example": "let bool = new Boolean(false); console.log(typeof bool); // 'object'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "When concatenating strings, the original string is modified directly in memory.",
          "answer": false,
          "explanation": "Strings are immutable, so concatenation creates a new string without modifying the original.",
          "example": "let str = 'hello'; let newStr = str + ' world'; console.log(str); // 'hello'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.charAt(0)` method returns the same result as using the index `string[0]`.",
          "answer": true,
          "explanation": "Both `.charAt(0)` and `string[0]` return the character at index 0, though `.charAt()` handles out-of-bounds differently.",
          "example": "let str = 'hello'; console.log(str.charAt(0), str[0]); // 'h' 'h'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Accessing a string with a negative index using `string[-1]` returns a valid character.",
          "answer": false,
          "explanation": "JavaScript strings do not support negative indexing with bracket notation; it returns `undefined`.",
          "example": "let str = 'hello'; console.log(str[-1]); // undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.slice()` method can accept negative indices to count from the end of the string.",
          "answer": true,
          "explanation": "`.slice()` supports negative indices, counting from the end of the string to extract a substring.",
          "example": "let str = 'hello'; console.log(str.slice(-2)); // 'lo'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.substring()` method treats negative indices as 0.",
          "answer": true,
          "explanation": "`.substring()` converts negative indices to 0, treating them as the start of the string.",
          "example": "let str = 'hello'; console.log(str.substring(-1, 2)); // 'he'"
        }
      ]
    }, 
  ],
  "3": [
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the output of `async function fetchData() { try { await fetch('invalid-url'); } catch (error) { console.log(error.name); } } fetchData();`?",
          "options": {
            "1": "ReferenceError",
            "2": "TypeError",
            "3": "Error",
            "4": "SyntaxError"
          },
          "answer": "3",
          "explanation": "An invalid URL in `fetch` throws a generic `Error` (e.g., 'Failed to fetch') in async code.",
          "example": "async function fetchData() { try { await fetch('invalid-url'); } catch (error) { console.log(error.name); } } fetchData(); // Outputs: Error"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "Asynchronous errors in `async` functions can be caught with `try-catch`.",
          "answer": true,
          "explanation": "In `async` functions, `try-catch` handles errors from `await`ed Promises.",
          "example": "async function fn() { try { await Promise.reject('Test'); } catch (error) { console.log(error); } } fn(); // Outputs: Test"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the output of `try { throw new Error('Inner'); } catch (error) { throw new Error('Outer: ' + error.message); } finally { console.log('Finally'); }`?",
          "options": {
            "1": "Inner \n Finally",
            "2": "Finally",
            "3": "Outer: Inner \n Finally",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "The `catch` block throws a new error, but `finally` runs before the error propagates.",
          "example": "try { throw new Error('Inner'); } catch (error) { throw new Error('Outer: ' + error.message); } finally { console.log('Finally'); } // Outputs: Finally, then crashes"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "A custom error class can extend the `Error` class to provide specific error types.",
          "answer": true,
          "explanation": "Extending `Error` allows custom error classes with specific names and behaviors.",
          "example": "class CustomError extends Error {} try { throw new CustomError('Test'); } catch (error) { console.log(error.name); } // Outputs: CustomError"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the best practice to avoid silent failures in a `try-catch` block?",
          "options": {
            "1": "Use an empty catch block",
            "2": "Log or handle errors",
            "3": "Ignore specific errors",
            "4": "Throw new errors"
          },
          "answer": "2",
          "explanation": "Logging or handling errors in the `catch` block prevents silent failures and aids debugging.",
          "example": "try { throw new Error('Test'); } catch (error) { console.log('Error:', error.message); } // Outputs: Error: Test"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "Nested `try-catch` blocks can handle errors at multiple levels.",
          "answer": true,
          "explanation": "Nested `try-catch` blocks allow errors to be caught and rethrown, enabling layered error handling.",
          "example": "try { try { throw new Error('Inner'); } catch (e) { throw new Error('Outer'); } } catch (e) { console.log(e.message); } // Outputs: Outer"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the output of `Promise.resolve().then(() => { throw new Error('Test'); }).catch(error => console.log(error.message));`?",
          "options": {
            "1": "Test",
            "2": "Error",
            "3": "undefined",
            "4": "null"
          },
          "answer": "1",
          "explanation": "The `.catch` method handles errors thrown in a Promise chain.",
          "example": "Promise.resolve().then(() => { throw new Error('Test'); }).catch(error => console.log(error.message)); // Outputs: Test"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "Errors thrown in a `finally` block can override errors from `try` or `catch`.",
          "answer": true,
          "explanation": "A new error thrown in `finally` replaces any prior error, potentially complicating debugging.",
          "example": "try { throw new Error('Try'); } catch (e) {} finally { throw new Error('Finally'); } // Crashes with Finally"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the output of `try { let x; console.log(x.name); } catch (error) { console.log(error.name); } finally { console.log('Done'); }`?",
          "options": {
            "1": "ReferenceError \n Done",
            "2": "TypeError \n Done",
            "3": "undefined \n Done",
            "4": "Error \n Done"
          },
          "answer": "2",
          "explanation": "Accessing `name` on `undefined` throws a `TypeError`, caught and logged, followed by `finally`.",
          "example": "try { let x; console.log(x.name); } catch (error) { console.log(error.name); } finally { console.log('Done'); } // Outputs: TypeError \n Done"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "Overusing `try-catch` can reduce code readability.",
          "answer": true,
          "explanation": "Wrapping all code in `try-catch` makes it harder to read and may impact performance.",
          "example": "// Bad: try { let x = 1; } catch (error) {} // Unnecessary"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the output of `async function fn() { try { await Promise.reject('Test'); } catch (error) { console.log(error); } finally { console.log('Done'); } } fn();`?",
          "options": {
            "1": "Test \n Done",
            "2": "Done",
            "3": "Error \n Done",
            "4": "undefined \n Done"
          },
          "answer": "1",
          "explanation": "The rejected Promise is caught in `try-catch`, and `finally` runs afterward.",
          "example": "async function fn() { try { await Promise.reject('Test'); } catch (error) { console.log(error); } finally { console.log('Done'); } } fn(); // Outputs: Test \n Done"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "A custom error class can include additional properties for context.",
          "answer": true,
          "explanation": "Custom error classes can extend `Error` and add properties for more context.",
          "example": "class CustomError extends Error { constructor(msg, code) { super(msg); this.code = code; } } try { throw new CustomError('Test', 400); } catch (e) { console.log(e.code); } // Outputs: 400"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the output of `try { try { throw new Error('Inner'); } catch (e) { throw new Error('Outer'); } } catch (e) { console.log(e.message); }`?",
          "options": {
            "1": "Inner",
            "2": "Outer",
            "3": "Error",
            "4": "undefined"
          },
          "answer": "2",
          "explanation": "The inner `catch` rethrows a new error, caught by the outer `catch`.",
          "example": "try { try { throw new Error('Inner'); } catch (e) { throw new Error('Outer'); } } catch (e) { console.log(e.message); } // Outputs: Outer"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "Errors in event listeners require specific handling to avoid uncaught exceptions.",
          "answer": true,
          "explanation": "Errors in event listeners can crash the application if not caught explicitly.",
          "example": "document.querySelector('button').addEventListener('click', () => { try { throw new Error('Test'); } catch (e) { console.log(e.message); } }); // Outputs: Test"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the output of `try { throw new Error('Test'); } catch (error) { console.log('Caught'); throw error; } finally { console.log('Done'); }`?",
          "options": {
            "1": "Caught \n Done",
            "2": "Done",
            "3": "Test \n Done",
            "4": "Caught"
          },
          "answer": "1",
          "explanation": "The `catch` block logs 'Caught', rethrows the error, and `finally` logs 'Done' before the error propagates.",
          "example": "try { throw new Error('Test'); } catch (error) { console.log('Caught'); throw error; } finally { console.log('Done'); } // Outputs: Caught \n Done, then crashes"
        }
      ]
    },
  {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the memory impact of `function outer() { let arr = new Array(1000).fill('data'); return () => arr; } let fn = outer(); fn = null;`?",
          "options": {
            "1": "Array persists in heap",
            "2": "Array is moved to stack",
            "3": "Array is eligible for garbage collection",
            "4": "Stack frame retains array"
          },
          "answer": "3",
          "explanation": "Setting `fn = null` removes the closure reference, making the array unreachable and eligible for garbage collection.",
          "example": "function outer() { let arr = new Array(1000).fill('data'); return () => arr; } let fn = outer(); fn = null;"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "A recursive function creates multiple stack frames that are popped after each call completes.",
          "answer": true,
          "explanation": "Each recursive call creates a new stack frame; frames are popped as calls return, freeing stack memory.",
          "example": "function recurse(n) { if (n <= 0) return; recurse(n-1); } recurse(3); // Multiple stack frames."
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the output of `let globalArr = []; function add() { globalArr.push(new Array(1000)); } add(); add(); globalArr = null; console.log(globalArr);`?",
          "options": {
            "1": "[Array(1000), Array(1000)]",
            "2": "null",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "Setting `globalArr = null` removes the reference, making the arrays eligible for garbage collection. `console.log` outputs `null`.",
          "example": "let globalArr = []; function add() { globalArr.push(new Array(1000)); } add(); add(); globalArr = null; console.log(globalArr); // Outputs: null"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "A memory leak can occur if a closure retains a large object unnecessarily.",
          "answer": true,
          "explanation": "Closures retain heap objects, causing leaks if large objects are unnecessarily referenced.",
          "example": "function outer() { let large = new Array(1000); return () => large; } let fn = outer(); // large retained."
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What happens to the objects in `function cycle() { let obj1 = { a: 1 }; let obj2 = { b: 2 }; obj1.ref = obj2; obj2.ref = obj1; } cycle();`?",
          "options": {
            "1": "They persist in memory",
            "2": "They are immediately collected",
            "3": "They are eligible for garbage collection",
            "4": "They move to the stack"
          },
          "answer": "3",
          "explanation": "The objects form a cycle but are unreachable after the function ends, so mark-and-sweep collects them.",
          "example": "function cycle() { let obj1 = { a: 1 }; let obj2 = { b: 2 }; obj1.ref = obj2; obj2.ref = obj1; } cycle();"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "The mark-and-sweep algorithm starts from roots like global variables and the stack.",
          "answer": true,
          "explanation": "Mark-and-sweep begins at roots (global variables, stack variables) to mark reachable objects.",
          "example": "let obj = { a: 1 }; // Root; marked as reachable."
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is a potential memory leak in `let timer = setInterval(() => console.log(new Array(1000)), 1000);`?",
          "options": {
            "1": "The array is stack-allocated",
            "2": "The timer is never cleared",
            "3": "The console.log is recursive",
            "4": "The interval is too short"
          },
          "answer": "2",
          "explanation": "An uncleared `setInterval` retains the callback and new arrays in the heap, causing a memory leak.",
          "example": "let timer = setInterval(() => console.log(new Array(1000)), 1000); // Fix: clearInterval(timer);"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "Reassigning a variable to a new object creates a new heap allocation and makes the old object eligible for collection if unreferenced.",
          "answer": true,
          "explanation": "A new heap allocation is created, and the old object becomes unreachable if no other references exist.",
          "example": "let obj = { a: 1 }; obj = { b: 2 }; // { a: 1 } eligible for collection."
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the output of `function outer() { let x = { a: 1 }; return () => x; } let fn1 = outer(); let fn2 = outer(); fn1 = null; console.log(typeof fn2);`?",
          "options": {
            "1": "null",
            "2": "function",
            "3": "object",
            "4": "undefined"
          },
          "answer": "2",
          "explanation": "Each call to `outer` creates a new closure. Setting `fn1 = null` affects only its closure; `fn2` retains its closure, so `typeof fn2` is 'function'.",
          "example": "function outer() { let x = { a: 1 }; return () => x; } let fn1 = outer(); let fn2 = outer(); fn1 = null; console.log(typeof fn2); // Outputs: function"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "Detached DOM elements can cause memory leaks if referenced in JavaScript.",
          "answer": true,
          "explanation": "DOM elements removed from the DOM but referenced in JavaScript remain in the heap, causing leaks.",
          "example": "let div = document.querySelector('div'); document.body.removeChild(div); // div retained in heap."
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the memory impact of `let arr = []; for (let i = 0; i < 1000; i++) arr.push({ id: i }); arr.length = 0;`?",
          "options": {
            "1": "Objects remain in heap",
            "2": "Objects are immediately collected",
            "3": "Objects are eligible for garbage collection",
            "4": "Objects move to stack"
          },
          "answer": "3",
          "explanation": "Setting `arr.length = 0` removes references to the objects, making them eligible for garbage collection.",
          "example": "let arr = []; for (let i = 0; i < 1000; i++) arr.push({ id: i }); arr.length = 0;"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "The garbage collector cannot collect objects referenced by active closures.",
          "answer": true,
          "explanation": "Active closures keep referenced objects in the heap, preventing garbage collection.",
          "example": "function outer() { let x = {}; return () => x; } let fn = outer(); // x retained."
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the best practice to prevent a memory leak in `let btn = document.querySelector('button'); btn.addEventListener('click', () => console.log('Click'));`?",
          "options": {
            "1": "Set btn to null",
            "2": "Use const instead of let",
            "3": "Remove the event listener",
            "4": "Use a primitive callback"
          },
          "answer": "3",
          "explanation": "Removing the event listener with `removeEventListener` frees the callback from the heap.",
          "example": "let btn = document.querySelector('button'); let fn = () => console.log('Click'); btn.addEventListener('click', fn); btn.removeEventListener('click', fn);"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "A large array retained by a closure can cause excessive memory usage.",
          "answer": true,
          "explanation": "Closures retaining large data structures like arrays keep them in the heap, increasing memory usage.",
          "example": "function outer() { let arr = new Array(1000); return () => arr; } let fn = outer(); // arr retained."
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the output of `let obj = { fn: function() { let x = new Array(1000); return () => x; } }; let fn = obj.fn(); obj = null; console.log(typeof fn);`?",
          "options": {
            "1": "null",
            "2": "function",
            "3": "object",
            "4": "undefined"
          },
          "answer": "2",
          "explanation": "The closure `fn` retains the array in the heap. Setting `obj = null` doesn’t affect `fn`, so `typeof fn` is 'function'.",
          "example": "let obj = { fn: function() { let x = new Array(1000); return () => x; } }; let fn = obj.fn(); obj = null; console.log(typeof fn); // Outputs: function"
        }
      ]
    },
    {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`hasOwnProperty()` in a closure can be used to filter out inherited properties when iterating over an object.",
        "answer": true,
        "explanation": "`hasOwnProperty()` checks if a property is directly defined on an object, useful in closures when iterating to avoid inherited properties.",
        "example": "function check() { let obj = { a: 1 }; Object.prototype.b = 2; return function() { for (let key in obj) { if (obj.hasOwnProperty(key)) console.log(key); } }; } let fn = check(); fn(); // Outputs: a"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `function createModule() { let obj = { x: 1 }; Object.prototype.y = 2; return { getOwn: function(key) { return obj.hasOwnProperty(key) ? obj[key] : 'Not own'; } }; } let mod = createModule(); console.log(mod.getOwn('x'), mod.getOwn('y'));`?",
        "options": {
          "1": "1, 2",
          "2": "1, Not own",
          "3": "Not own, Not own",
          "4": "ReferenceError"
        },
        "answer": "2",
        "explanation": "The `getOwn` method uses `hasOwnProperty` to check if the property is own. `x` is own, but `y` is inherited, so it returns 'Not own'.",
        "example": "function createModule() { let obj = { x: 1 }; Object.prototype.y = 2; return { getOwn: function(key) { return obj.hasOwnProperty(key) ? obj[key] : 'Not own'; } }; } let mod = createModule(); console.log(mod.getOwn('x'), mod.getOwn('y')); // Outputs: 1, Not own"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "An Immediately Invoked Function Expression (IIFE) creates a private scope to avoid polluting the global scope.",
        "answer": true,
        "explanation": "An IIFE executes immediately and creates a private scope, preventing its variables from being added to the global scope.",
        "example": "(function() { let x = 1; console.log(x); })(); console.log(typeof x); // Outputs: 1, undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `(function() { let x = 'secret'; return function() { console.log(x); }; })()();`?",
        "options": {
          "1": "secret",
          "2": "undefined",
          "3": "ReferenceError",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The IIFE returns a closure that retains access to `x`. Calling the returned function immediately logs `x`.",
        "example": "(function() { let x = 'secret'; return function() { console.log(x); }; })()(); // Outputs: secret"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A closure capturing a variable in a loop can lead to unexpected behavior if `var` is used instead of `let`.",
        "answer": true,
        "explanation": "Using `var` in a loop creates a single variable shared across all iterations, causing closures to capture the final value, whereas `let` creates a new binding per iteration.",
        "example": "let fns = []; for (var i = 0; i < 2; i++) { fns.push(() => console.log(i)); } fns[0](); fns[1](); // Outputs: 2, 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let fns = []; for (let i = 0; i < 2; i++) { fns.push(() => console.log(i)); } fns[0](); fns[1]();`?",
        "options": {
          "1": "0, 0",
          "2": "0, 1",
          "3": "2, 2",
          "4": "ReferenceError"
        },
        "answer": "2",
        "explanation": "Using `let` in the loop creates a new binding for `i` per iteration, so each closure captures its own `i` value.",
        "example": "let fns = []; for (let i = 0; i < 2; i++) { fns.push(() => console.log(i)); } fns[0](); fns[1](); // Outputs: 0, 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A closure’s captured variables are stored in the heap to persist after the outer function finishes.",
        "answer": true,
        "explanation": "Variables captured by a closure are stored in the heap to remain accessible after the outer function’s execution, preventing garbage collection.",
        "example": "function outer() { let x = 1; return function() { console.log(x); }; } let fn = outer(); fn(); // Outputs: 1"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `function outer() { let x = 1; return { inc: function() { x++; }, get: function() { return x; } }; } let obj1 = outer(); let obj2 = outer(); obj1.inc(); console.log(obj1.get(), obj2.get());`?",
        "options": {
          "1": "2, 1",
          "2": "2, 2",
          "3": "1, 1",
          "4": "ReferenceError"
        },
        "answer": "1",
        "explanation": "Each call to `outer` creates a new closure with its own `x`. `obj1.inc()` increments `obj1`’s `x`, but `obj2`’s `x` remains unchanged.",
        "example": "function outer() { let x = 1; return { inc: function() { x++; }, get: function() { return x; } }; } let obj1 = outer(); let obj2 = outer(); obj1.inc(); console.log(obj1.get(), obj2.get()); // Outputs: 2, 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "An IIFE can return an object to create a module pattern with private variables.",
        "answer": true,
        "explanation": "An IIFE can return an object with methods that form closures over private variables, implementing the module pattern.",
        "example": "(function() { let x = 1; return { getX: function() { return x; } }; })().getX(); // Outputs: 1"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `function outer() { let x = 1; function inner() { let x = 2; return function() { console.log(x); }; } return inner(); } let fn = outer(); fn();`?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "ReferenceError",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The innermost function forms a closure over the `x` in `inner`, which shadows the `x` in `outer`, so it logs `2`.",
        "example": "function outer() { let x = 1; function inner() { let x = 2; return function() { console.log(x); }; } return inner(); } let fn = outer(); fn(); // Outputs: 2"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Setting a closure to `null` allows its captured variables to be garbage collected if no other references exist.",
        "answer": true,
        "explanation": "When a closure is no longer referenced, its captured variables become eligible for garbage collection if no other references exist.",
        "example": "function outer() { let x = 1; return function() { console.log(x); }; } let fn = outer(); fn = null; // x is eligible for garbage collection"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `const module = (function() { let x = 1; return { setX: function(val) { x = val; }, getX: function() { return x; } }; })(); module.setX(5); console.log(module.getX());`?",
        "options": {
          "1": "1",
          "2": "5",
          "3": "ReferenceError",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The module pattern creates a closure, allowing `setX` to modify the private `x` and `getX` to retrieve it.",
        "example": "const module = (function() { let x = 1; return { setX: function(val) { x = val; }, getX: function() { return x; } }; })(); module.setX(5); console.log(module.getX()); // Outputs: 5"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A closure can capture variables from multiple levels of outer scopes.",
        "answer": true,
        "explanation": "A closure can access variables from all outer scopes in its scope chain, including multiple nested levels.",
        "example": "function outer() { let x = 1; function middle() { let y = 2; return function() { console.log(x + y); }; } return middle(); } let fn = outer(); fn(); // Outputs: 3"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `function outer() { let x = 1; return function() { x = 2; return function() { console.log(x); }; }; } let fn = outer()(); fn();`?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "ReferenceError",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The first returned function modifies `x` to 2 and returns another function that logs `x`, which is captured via closure.",
        "example": "function outer() { let x = 1; return function() { x = 2; return function() { console.log(x); }; }; } let fn = outer()(); fn(); // Outputs: 2"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Using `var` in a block scope inside a function makes the variable accessible throughout the function.",
        "answer": true,
        "explanation": "Variables declared with `var` are function-scoped, so a `var` declared in a block inside a function is accessible throughout the function.",
        "example": "function test() { if (true) { var x = 1; } console.log(x); } test(); // Outputs: 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "In a `switch` statement, omitting a `break` causes fall-through to the next case.",
        "answer": true,
        "explanation": "Without a `break`, a `switch` statement continues executing subsequent cases until a `break` or the end of the `switch` is reached (fall-through behavior).",
        "example": "let x = 1; switch (x) { case 1: console.log('One'); case 2: console.log('Two'); break; } // Outputs: One, Two"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let obj = {a: 1, b: 2}; for (let key of Object.keys(obj)) { if (obj[key] > 1) console.log(key); }`?",
        "options": {
          "1": "a",
          "2": "b",
          "3": "a, b",
          "4": "Nothing"
        },
        "answer": "2",
        "explanation": "`Object.keys(obj)` returns `['a', 'b']`. The `for...of` loop checks each value, logging the key if `obj[key] > 1`. Only `b` (value 2) meets the condition.",
        "example": "let obj = {a: 1, b: 2}; for (let key of Object.keys(obj)) { if (obj[key] > 1) console.log(key); } // Outputs: b"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`hasOwnProperty()` returns `false` for inherited properties in a `for...in` loop.",
        "answer": true,
        "explanation": "`hasOwnProperty()` checks if a property is directly defined on an object, returning `false` for properties inherited from the prototype chain.",
        "example": "let obj = {a: 1}; Object.prototype.b = 2; for (let key in obj) { console.log(obj.hasOwnProperty(key)); } // Outputs: true, false"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `try { for (let i = 0; i < 3; i++) { if (i === 2) throw new Error('Stop'); console.log(i); } } catch (e) { console.log('Caught'); }`?",
        "options": {
          "1": "0, 1, Caught",
          "2": "0, 1, 2",
          "3": "Caught",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The loop logs `0` and `1`, then throws an error when `i === 2`. The `catch` block logs 'Caught'.",
        "example": "try { for (let i = 0; i < 3; i++) { if (i === 2) throw new Error('Stop'); console.log(i); } } catch (e) { console.log('Caught'); } // Outputs: 0, 1, Caught"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A labeled `continue` statement can skip to the next iteration of an outer loop in a nested loop.",
        "answer": true,
        "explanation": "A labeled `continue` statement can skip to the next iteration of a specific outer loop in a nested loop structure.",
        "example": "outer: for (let i = 0; i < 2; i++) { for (let j = 0; j < 2; j++) { if (j === 1) continue outer; console.log(j); } } // Outputs: 0, 0"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2, 3]; for (let i of arr) { if (i === 2) break; console.log(i); }`?",
        "options": {
          "1": "1",
          "2": "1, 2",
          "3": "1, 2, 3",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `for...of` loop iterates over the array. When `i === 2`, the `break` statement exits the loop, so only `1` is logged.",
        "example": "let arr = [1, 2, 3]; for (let i of arr) { if (i === 2) break; console.log(i); } // Outputs: 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`Object.values()` returns an array of an object’s enumerable property values, which can be used in a `for...of` loop.",
        "answer": true,
        "explanation": "`Object.values()` returns an array of an object’s enumerable property values, suitable for iteration with `for...of`.",
        "example": "let obj = {a: 1, b: 2}; for (let val of Object.values(obj)) { console.log(val); } // Outputs: 1, 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let x = 0; console.log(x || 1 && 2 || 3);`?",
        "options": {
          "1": "0",
          "2": "1",
          "3": "2",
          "4": "3"
        },
        "answer": "3",
        "explanation": "The `&&` operator has higher precedence and returns `2` (last truthy value). The `||` operator then evaluates `0 || 2 || 3`, returning `2` (first truthy value).",
        "example": "let x = 0; console.log(x || 1 && 2 || 3); // Outputs: 2"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Using `Object.freeze()` on an object prevents its properties from being modified in a loop.",
        "answer": true,
        "explanation": "`Object.freeze()` makes an object immutable, preventing property modifications in loops or conditionals.",
        "example": "let obj = {a: 1}; Object.freeze(obj); for (let key in obj) { obj[key] = 2; } console.log(obj.a); // Outputs: 1"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let matrix = [[1, 2], [3, 4]]; outer: for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[i].length; j++) { if (matrix[i][j] === 3) break outer; console.log(matrix[i][j]); } }`?",
        "options": {
          "1": "1, 2",
          "2": "1, 2, 3",
          "3": "1, 2, 3, 4",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The labeled `break outer` exits both loops when `matrix[i][j] === 3`, so only `1` and `2` are logged.",
        "example": "let matrix = [[1, 2], [3, 4]]; outer: for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[i].length; j++) { if (matrix[i][j] === 3) break outer; console.log(matrix[i][j]); } } // Outputs: 1, 2"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Using `Object.seal()` on an object allows modifying existing properties but prevents adding new ones in a loop.",
        "answer": true,
        "explanation": "`Object.seal()` prevents adding or removing properties but allows modifying existing ones, which can affect loop behavior.",
        "example": "let obj = {a: 1}; Object.seal(obj); for (let key in obj) { obj[key] = 2; } console.log(obj.a); // Outputs: 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 'two', 3]; try { for (let x of arr) { if (isNaN(x)) throw new Error('Invalid'); console.log(x); } } catch (e) { console.log('Error caught'); }`?",
        "options": {
          "1": "1, Error caught",
          "2": "1, two, 3",
          "3": "1, 3, Error caught",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The loop logs `1`, then throws an error when `x` is `'two'` (non-numeric). The `catch` block logs 'Error caught'.",
        "example": "let arr = [1, 'two', 3]; try { for (let x of arr) { if (isNaN(x)) throw new Error('Invalid'); console.log(x); } } catch (e) { console.log('Error caught'); } // Outputs: 1, Error caught"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A `for...in` loop skips non-enumerable properties of an object.",
        "answer": true,
        "explanation": "A `for...in` loop only iterates over enumerable properties, skipping non-enumerable ones defined with `Object.defineProperty`.",
        "example": "let obj = {a: 1}; Object.defineProperty(obj, 'b', {value: 2, enumerable: false}); for (let key in obj) { console.log(key); } // Outputs: a"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let obj = {a: 1, b: 2}; Object.defineProperty(obj, 'b', {enumerable: false}); for (let key in obj) { console.log(key); }`?",
        "options": {
          "1": "a, b",
          "2": "a",
          "3": "b",
          "4": "Nothing"
        },
        "answer": "2",
        "explanation": "After setting `b` as non-enumerable with `Object.defineProperty`, the `for...in` loop only iterates over `a`, the remaining enumerable property.",
        "example": "let obj = {a: 1, b: 2}; Object.defineProperty(obj, 'b', {enumerable: false}); for (let key in obj) { console.log(key); } // Outputs: a"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `||` operator short-circuits and returns the first truthy value or the last value if none are truthy.",
        "answer": true,
        "explanation": "The `||` operator evaluates expressions from left to right, returning the first truthy value or the last value if all are falsy.",
        "example": "let x = 0; let y = ''; console.log(x || y || 'last'); // Outputs: last"
      }
    ]
  },
    {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Arrow functions inherit the `arguments` object from their enclosing scope.",
        "answer": true,
        "explanation": "Arrow functions do not have their own `arguments` object and instead inherit it from the enclosing non-arrow function or global scope.",
        "example": "function outer() { return () => console.log(arguments[0]); } outer('test')(); // test"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Using `Object.freeze()` on a function prevents adding new properties but allows modifying existing ones.",
        "answer": false,
        "explanation": "`Object.freeze()` prevents adding, removing, or modifying properties on a function (or any object).",
        "example": "function fn() {} fn.prop = 'test'; Object.freeze(fn); fn.prop = 'new'; console.log(fn.prop); // test"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `function fn() {} console.log(Object.keys(fn));` return if no custom properties are added?",
        "options": {
          "1": "[]",
          "2": "['name', 'length']",
          "3": "['prototype']",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`Object.keys()` returns an array of a function’s enumerable own properties. Built-in properties like `name` and `length` are non-enumerable, so an empty array is returned.",
        "example": "function fn() {} console.log(Object.keys(fn)); // []"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Closures can cause memory leaks if not managed properly.",
        "answer": true,
        "explanation": "Closures retain references to outer scope variables, which can prevent garbage collection if the closure persists, potentially causing memory leaks.",
        "example": "function outer() { let largeObj = new Array(1000000).fill(0); return () => largeObj; } const fn = outer(); // largeObj persists in memory"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `const fn = function named() { console.log(typeof named); }; fn();` output?",
        "options": {
          "1": "function",
          "2": "undefined",
          "3": "Error",
          "4": "string"
        },
        "answer": "1",
        "explanation": "In a named function expression, the function’s name (`named`) is only accessible within its own scope, and `typeof named` returns 'function'.",
        "example": "const fn = function named() { console.log(typeof named); }; fn(); // function"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `apply()` method passes arguments as individual parameters like `call()`.",
        "answer": false,
        "explanation": "`apply()` passes arguments as an array, while `call()` passes them individually.",
        "example": "function fn(a, b) { console.log(a + b); } fn.call(null, 1, 2); // 3, fn.apply(null, [1, 2]); // 3"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `const obj = (function() { let x = 10; return { get: () => x, set: v => x = v }; })(); obj.set(20); console.log(obj.get());` return?",
        "options": {
          "1": "20",
          "2": "10",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The IIFE creates a closure, allowing the returned object’s methods to access and modify the private variable `x`. After setting `x` to 20, `get()` returns 20.",
        "example": "const obj = (function() { let x = 10; return { get: () => x, set: v => x = v }; })(); obj.set(20); console.log(obj.get()); // 20"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A function’s `prototype` property is only available for constructor functions.",
        "answer": true,
        "explanation": "All functions (except arrow functions) have a `prototype` property, which is used when the function is invoked as a constructor with `new`.",
        "example": "function fn() {} console.log(fn.prototype); // { constructor: fn }; const af = () => {}; console.log(af.prototype); // undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the result of `async function fn() { return 'Done'; } fn().then(console.log);`?",
        "options": {
          "1": "Done",
          "2": "Promise { 'Done' }",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Async functions return a Promise, and the `then` method logs the resolved value 'Done'.",
        "example": "async function fn() { return 'Done'; } fn().then(console.log); // Done"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Using `Object.seal()` on a function allows modifying existing properties but prevents adding new ones.",
        "answer": true,
        "explanation": "`Object.seal()` prevents adding or removing properties but allows modifying the values of existing properties.",
        "example": "function fn() {} fn.prop = 'test'; Object.seal(fn); fn.prop = 'new'; fn.newProp = 'x'; console.log(fn.prop, fn.newProp); // new, undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `function fn() {} fn.prop = 'test'; console.log(fn.hasOwnProperty('prop'));` return?",
        "options": {
          "1": "true",
          "2": "false",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`hasOwnProperty()` checks if a property exists directly on the function object, returning `true` for the added `prop` property.",
        "example": "function fn() {} fn.prop = 'test'; console.log(fn.hasOwnProperty('prop')); // true"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A named function expression’s name is accessible outside its scope.",
        "answer": false,
        "explanation": "The name of a named function expression is only accessible within the function’s own scope, not externally.",
        "example": "const fn = function named() { console.log(typeof named); }; fn(); // function, console.log(typeof named); // undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "Which of the following correctly creates a function using the revealing module pattern?",
        "options": {
          "1": "const module = (function() { let x = 0; function inc() { x++; } return { inc }; })();",
          "2": "const module = function() { let x = 0; return x; };",
          "3": "const module = () => { let x = 0; x++; };",
          "4": "const module = function inc() { let x = 0; return x; };"
        },
        "answer": "1",
        "explanation": "The revealing module pattern uses an IIFE to create a closure, returning an object that exposes private methods like `inc` while keeping `x` private.",
        "example": "const module = (function() { let x = 0; function inc() { x++; } return { inc }; })(); module.inc();"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Functions declared with `const` cannot have their properties modified.",
        "answer": false,
        "explanation": "`const` prevents reassignment of the function itself, but since functions are objects, their properties can still be modified.",
        "example": "const fn = function() {}; fn.prop = 'test'; console.log(fn.prop); // test"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `function outer() { let x = 1; return function() { return x++; }; } const fn1 = outer(); const fn2 = outer(); console.log(fn1(), fn2());` return?",
        "options": {
          "1": "1, 1",
          "2": "1, 2",
          "3": "2, 1",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Each call to `outer()` creates a new closure with its own `x`. Thus, `fn1` and `fn2` each start with `x = 1`, returning 1 for their first calls.",
        "example": "function outer() { let x = 1; return function() { return x++; }; } const fn1 = outer(); const fn2 = outer(); console.log(fn1(), fn2()); // 1, 1"
      }
    ]
  },
        {
        "type": 1,
        "level": "hard",
        "question": [
          {
            "question": "`Object.defineProperties()` can define multiple non-enumerable properties simultaneously.",
            "answer": true,
            "explanation": "`Object.defineProperties()` allows defining multiple properties with descriptors, setting `enumerable: false` to exclude them from `for...in` loops.",
            "example": "let obj = {}; Object.defineProperties(obj, { a: { value: 1, enumerable: false }, b: { value: 2, enumerable: false } }); for (let key in obj) { console.log(key); } // no output"
          }
        ]
      },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What happens when you execute `let arr = [1, 2, 3]; console.log(arr.splice(1, 1, 'a'));`?",
          "options": {
            "1": "['a']",
            "2": "[2]",
            "3": "[1, 'a', 3]",
            "4": "[1, 2, 3]"
          },
          "answer": "2",
          "explanation": "`.splice(1, 1, 'a')` removes 1 element at index 1 (the value 2) and inserts 'a', returning the removed elements `[2]`. The array becomes `[1, 'a', 3]`.",
          "example": "let arr = [1, 2, 3]; console.log(arr.splice(1, 1, 'a')); console.log(arr); // [2], [1, 'a', 3]"
        }
      ]
    },
     {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Modifying a property on an object created with `Object.create()` can affect the prototype if the property is not shadowed.",
        "answer": true,
        "explanation": "If a property is not defined as an own property on the object, modifying it updates the prototype’s property, as it’s accessed via the prototype chain.",
        "example": "let proto = { name: 'Luiz' }; let obj = Object.create(proto); proto.name = 'Marta'; console.log(obj.name); // 'Marta'"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Factory Functions create a new copy of methods for each object, leading to higher memory usage compared to Class Syntax.",
        "answer": true,
        "explanation": "Factory Functions duplicate methods for each object, while Class Syntax shares methods via the prototype, optimizing memory.",
        "example": "function createObj() { return { greet: () => 'Hi' }; } let obj1 = createObj(); let obj2 = createObj(); console.log(obj1.greet === obj2.greet); // false"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A class constructor that omits `super()` in a subclass causes a `ReferenceError` if `this` is used before calling `super`.",
        "answer": true,
        "explanation": "In a subclass, `this` cannot be accessed before calling `super()`, as the parent class must initialize the instance first.",
        "example": "class Parent {} class Child extends Parent { constructor() { this.name = 'Luiz'; super(); } } let c = new Child(); // ReferenceError: Must call super constructor before using 'this'"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`Object.create()` with a non-enumerable prototype property prevents that property from appearing in `for...in` loops on the derived object.",
        "answer": true,
        "explanation": "Non-enumerable properties in the prototype are not iterated over in `for...in` loops, even if accessible via the prototype chain.",
        "example": "let proto = Object.defineProperty({}, 'name', { value: 'Luiz', enumerable: false }); let obj = Object.create(proto); for (let key in obj) { console.log(key); } // no output"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Using `Object.defineProperty()` on a `new Object()` instance can make a property non-writable, preventing future modifications.",
        "answer": true,
        "explanation": "`Object.defineProperty()` can set `writable: false`, making a property immutable unless reconfigured with `configurable: true`.",
        "example": "let obj = new Object(); Object.defineProperty(obj, 'name', { value: 'Luiz', writable: false }); obj.name = 'Marta'; console.log(obj.name); // 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `function Person(name) { this.name = name; } Person.prototype.greet = function() { return 'Hi'; }; let p = new Person('Luiz'); delete p.greet; console.log(p.greet());`?",
        "options": {
          "1": "'Hi'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Deleting `p.greet` removes any own `greet` property, but the prototype’s `greet` method is still accessible via the prototype chain.",
        "example": "function Person(name) { this.name = name; } Person.prototype.greet = function() { return 'Hi'; }; let p = new Person('Luiz'); delete p.greet; console.log(p.greet()); // 'Hi'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let proto = { name: 'Luiz' }; let obj = Object.create(proto); Object.defineProperty(obj, 'name', { value: 'Marta', writable: false }); obj.name = 'John'; console.log(obj.name);` return?",
        "options": {
          "1": "'Luiz'",
          "2": "'Marta'",
          "3": "'John'",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "Defining `name` as non-writable on `obj` creates an own property, shadowing the prototype’s `name`. The assignment `obj.name = 'John'` has no effect.",
        "example": "let proto = { name: 'Luiz' }; let obj = Object.create(proto); Object.defineProperty(obj, 'name', { value: 'Marta', writable: false }); obj.name = 'John'; console.log(obj.name); // 'Marta'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `class Parent { constructor() { this.name = 'Luiz'; } } class Child extends Parent { constructor() { super(); this.name = 'Marta'; } } let c = new Child(); console.log(c.name, Object.getPrototypeOf(c).name);`?",
        "options": {
          "1": "'Marta', undefined",
          "2": "'Marta', 'Luiz'",
          "3": "'Luiz', 'Marta'",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `Child` constructor sets `name` to 'Marta' after calling `super()`. The prototype (Parent instance) has no own `name` property, so it’s `undefined`.",
        "example": "class Parent { constructor() { this.name = 'Luiz'; } } class Child extends Parent { constructor() { super(); this.name = 'Marta'; } } let c = new Child(); console.log(c.name, Object.getPrototypeOf(c).name); // 'Marta', undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `function createObj() { let secret = 'hidden'; return { getSecret: () => secret }; } let obj1 = createObj(); let obj2 = createObj(); secret = 'changed'; console.log(obj1.getSecret());` return?",
        "options": {
          "1": "'hidden'",
          "2": "'changed'",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `secret` variable is private to each `createObj` call via closure. Changing `secret` outside does not affect the closure’s value.",
        "example": "function createObj() { let secret = 'hidden'; return { getSecret: () => secret }; } let obj1 = createObj(); let obj2 = createObj(); secret = 'changed'; console.log(obj1.getSecret()); // 'hidden'"
      }
    ]
  },
  {
  "type": 2,
  "level": "hard",
  "question": [
    {
      "question": "What is the result of `let arr = [1,,3]; console.log(arr.map(x => x * 2));`?",
      "options": {
        "1": "[2, undefined, 6]",
        "2": "[2, , 6]",
        "3": "[2, null, 6]",
        "4": "Error"
      },
      "answer": "2",
      "explanation": "`map()` processes only defined elements, preserving empty slots in sparse arrays, resulting in `[2, , 6]`.",
      "example": "let arr = [1,,3]; console.log(arr.map(x => x * 2)); // [2, , 6]"
    }
  ]
},
{
  "type": 1,
  "level": "hard",
  "question": [
    {
      "question": "`Object.getOwnPropertyDescriptors()` includes both enumerable and non-enumerable properties with their descriptors.",
      "answer": true,
      "explanation": "`Object.getOwnPropertyDescriptors()` returns an object with descriptors for all own properties, including non-enumerable ones.",
      "example": "let obj = { a: 1 }; Object.defineProperty(obj, 'b', { value: 2, enumerable: false }); console.log(Object.getOwnPropertyDescriptors(obj)); // { a: { value: 1, ... }, b: { value: 2, ... } }"
    }
  ]
}, 
{
  "type": 2,
  "level": "hard",
  "question": [
    {
      "question": "What is the result of `let str = 'hello world'; console.log(str.match(/(\\w+)\\s(\\w+)/));`?",
      "options": {
        "1": "['hello world', 'hello', 'world']",
        "2": "['hello', 'world']",
        "3": "null",
        "4": "Error"
      },
      "answer": "1",
      "explanation": "The regex `(\\w+)\\s(\\w+)` matches two words separated by a space, capturing each word. The result includes the full match and capture groups.",
      "example": "let str = 'hello world'; console.log(str.match(/(\\w+)\\s(\\w+)/)); // ['hello world', 'hello', 'world']"
    }
  ]
},
{
  "type": 2,
  "level": "hard",
  "question": [
    {
      "question": "What is the result of `console.log(Math.abs(Number.EPSILON - (0.2 - 0.2)) < Number.EPSILON);`?",
      "options": {
        "1": "true",
        "2": "false",
        "3": "undefined",
        "4": "Error"
      },
      "answer": "1",
      "explanation": "`Number.EPSILON` represents the smallest difference between 1 and the next representable number. Since `0.2 - 0.2` is 0, the difference is less than `Number.EPSILON`, returning `true`.",
      "example": "console.log(Math.abs(Number.EPSILON - (0.2 - 0.2)) < Number.EPSILON); // true"
    }
  ]
},
{
  "type": 1,
  "level": "hard",
  "question": [
    {
      "question": "The expression `null && 'hello'` evaluates to `null` in a boolean context.",
      "answer": true,
      "explanation": "The `&&` operator short-circuits and returns `null` if the first operand is falsy, without evaluating the second operand.",
      "example": "console.log(null && 'hello'); // null"
    }
  ]
},
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let obj = { [Symbol.toStringTag]: 'Custom' }; console.log(Object.prototype.toString.call(obj));`?",
        "options": {
          "1": "[object Custom]",
          "2": "[object Object]",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `Symbol.toStringTag` property customizes the result of `Object.prototype.toString.call()`, returning '[object Custom]' for the object.",
        "example": "let obj = { [Symbol.toStringTag]: 'Custom' }; console.log(Object.prototype.toString.call(obj)); // [object Custom]"
      }
    ]
  },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: 1 }; Object.assign(obj, { b: 2 }); console.log(obj);`?",
          "options": {
            "1": "{ a: 1 }",
            "2": "{ b: 2 }",
            "3": "{ a: 1, b: 2 }",
            "4": "{}"
          },
          "answer": "3",
          "explanation": "`Object.assign()` merges properties from the source object into the target, modifying the target to include both `a` and `b`.",
          "example": "let obj = { a: 1 }; Object.assign(obj, { b: 2 }); console.log(obj); // { a: 1, b: 2 }"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let obj = { a: 1 }; Object.freeze(obj); obj.a = 2; console.log(obj.a);` return?",
          "options": {
            "1": "1",
            "2": "2",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "`Object.freeze()` makes the object immutable, preventing modifications to existing properties, so `obj.a` remains 1.",
          "example": "let obj = { a: 1 }; Object.freeze(obj); obj.a = 2; console.log(obj.a); // 1"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: 1 }; Object.seal(obj); obj.a = 2; console.log(obj);`?",
          "options": {
            "1": "{ a: 1 }",
            "2": "{ a: 2 }",
            "3": "{}",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "`Object.seal()` allows modifying existing properties but prevents adding or deleting properties, so `obj.a` is updated to 2.",
          "example": "let obj = { a: 1 }; Object.seal(obj); obj.a = 2; console.log(obj); // { a: 2 }"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let proto = { a: 1 }; let obj = Object.create(proto); console.log(obj.hasOwnProperty('a'));` return?",
          "options": {
            "1": "true",
            "2": "false",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "`hasOwnProperty()` checks for own properties, not inherited ones. Since `a` is on the prototype, it returns `false`.",
          "example": "let proto = { a: 1 }; let obj = Object.create(proto); console.log(obj.hasOwnProperty('a')); // false"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: 1, b: { c: 2 } }; let copy = JSON.parse(JSON.stringify(obj)); copy.b.c = 3; console.log(obj.b.c);`?",
          "options": {
            "1": "2",
            "2": "3",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "`JSON.parse(JSON.stringify())` creates a deep copy, so modifying `copy.b.c` does not affect `obj.b.c`.",
          "example": "let obj = { a: 1, b: { c: 2 } }; let copy = JSON.parse(JSON.stringify(obj)); copy.b.c = 3; console.log(obj.b.c); // 2"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "The `JSON.parse(JSON.stringify())` method can copy methods of an object.",
          "answer": false,
          "explanation": "`JSON.stringify()` does not serialize functions, so methods are excluded in the deep copy created by `JSON.parse(JSON.stringify())`.",
          "example": "let obj = { a: 1, f: () => 'hi' }; let copy = JSON.parse(JSON.stringify(obj)); console.log(copy.f); // undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "The `Object.getOwnPropertyNames()` method returns both enumerable and non-enumerable own properties.",
          "answer": true,
          "explanation": "`Object.getOwnPropertyNames()` returns all own property names, including non-enumerable ones, unlike `Object.keys()`.",
          "example": "let obj = { a: 1 }; Object.defineProperty(obj, 'b', { value: 2, enumerable: false }); console.log(Object.getOwnPropertyNames(obj)); // ['a', 'b']"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: 1 }; Object.defineProperty(obj, 'b', { value: 2, enumerable: false }); console.log(Object.keys(obj));`?",
          "options": {
            "1": "['a', 'b']",
            "2": "['a']",
            "3": "['b']",
            "4": "[]"
          },
          "answer": "2",
          "explanation": "`Object.keys()` returns only enumerable own properties, so `b` (non-enumerable) is excluded.",
          "example": "let obj = { a: 1 }; Object.defineProperty(obj, 'b', { value: 2, enumerable: false }); console.log(Object.keys(obj)); // ['a']"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let entries = [['x', 10], ['y', 20]]; console.log(Object.fromEntries(entries));` return?",
          "options": {
            "1": "{ x: 10, y: 20 }",
            "2": "[['x', 10], ['y', 20]]",
            "3": "{ 10: 'x', 20: 'y' }",
            "4": "undefined"
          },
          "answer": "1",
          "explanation": "`Object.fromEntries()` transforms an array of key-value pairs into an object, creating `{ x: 10, y: 20 }`.",
          "example": "let entries = [['x', 10], ['y', 20]]; console.log(Object.fromEntries(entries)); // { x: 10, y: 20 }"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let objA = { a: 1 }; let objB = objA; objB.a = 2; console.log(objA.a);`?",
          "options": {
            "1": "1",
            "2": "2",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "Since `objB` is a reference to `objA`, modifying `objB.a` changes `objA.a` as they point to the same object.",
          "example": "let objA = { a: 1 }; let objB = objA; objB.a = 2; console.log(objA.a); // 2"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let obj = { a: 1, b: 2 }; console.log(Object.entries(obj));` return?",
          "options": {
            "1": "[['a', 1], ['b', 2]]",
            "2": "['a', 'b']",
            "3": "[1, 2]",
            "4": "{ a: 1, b: 2 }"
          },
          "answer": "1",
          "explanation": "`Object.entries()` returns an array of arrays, each containing a key-value pair of the object's enumerable properties.",
          "example": "let obj = { a: 1, b: 2 }; console.log(Object.entries(obj)); // [['a', 1], ['b', 2]]"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "The `Object.defineProperty()` method can make a property non-writable.",
          "answer": true,
          "explanation": "`Object.defineProperty()` can set a property's `writable` attribute to `false`, preventing value changes.",
          "example": "let obj = {}; Object.defineProperty(obj, 'a', { value: 1, writable: false }); obj.a = 2; console.log(obj.a); // 1"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: NaN }; console.log(Object.is(obj.a, NaN));`?",
          "options": {
            "1": "true",
            "2": "false",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "`Object.is()` performs strict equality, correctly identifying `NaN` as equal to itself, unlike `===`.",
          "example": "let obj = { a: NaN }; console.log(Object.is(obj.a, NaN)); // true"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let obj = { name: 'Luiz', details: { age: 29 } }; let copy = { ...obj }; copy.details.age = 30; console.log(obj.details.age);` return?",
          "options": {
            "1": "29",
            "2": "30",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "The spread operator creates a shallow copy, so `details` is still a reference to the same nested object, and modifying `copy.details.age` affects `obj.details.age`.",
          "example": "let obj = { name: 'Luiz', details: { age: 29 } }; let copy = { ...obj }; copy.details.age = 30; console.log(obj.details.age); // 30"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `console.log(Number.isSafeInteger(9007199254740992));`?",
          "options": {
            "1": "true",
            "2": "false",
            "3": "undefined",
            "4": "NaN"
          },
          "answer": "2",
          "explanation": "`Number.isSafeInteger()` returns `false` for numbers beyond `Number.MAX_SAFE_INTEGER` (2^53 - 1), as 9007199254740992 exceeds this limit and may lose precision.",
          "example": "console.log(Number.isSafeInteger(9007199254740992)); // false"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: null }; console.log(obj.a === null);`?",
          "options": {
            "1": "true",
            "2": "false",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "The `===` operator checks for strict equality in both value and type. Since `obj.a` is explicitly `null`, `obj.a === null` returns `true`.",
          "example": "let obj = { a: null }; console.log(obj.a === null); // true"
        }
      ]
    },
     {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A `let` variable declared in a `for` loop creates a new binding for each iteration, preventing closure issues with asynchronous code.",
        "answer": true,
        "explanation": "Each iteration of a `for` loop with `let` creates a new block-scoped binding, ensuring that asynchronous callbacks capture the correct value for each iteration, unlike `var`.",
        "example": "for (let i = 0; i < 3; i++) { setTimeout(() => console.log(i), 0); } // 0, 1, 2"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Redeclaring a `const` variable in a nested block scope does not throw a syntax error.",
        "answer": true,
        "explanation": "A `const` variable can be redeclared in a nested block scope because it creates a new binding in a different scope, adhering to block scoping rules.",
        "example": "const x = 1; { const x = 2; console.log(x); } console.log(x); // 2, 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `String.prototype.slice()` method handles negative indices differently than `substring()`, counting from the end of the string.",
        "answer": true,
        "explanation": "`slice()` interprets negative indices as counting from the string's end, while `substring()` treats them as 0, leading to different substring extractions.",
        "example": "let str = 'hello'; console.log(str.slice(-2), str.substring(-2)); // 'lo', 'hello'"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`Object.defineProperties()` can define non-enumerable properties, excluding them from `for...in` loops.",
        "answer": true,
        "explanation": "`Object.defineProperties()` allows setting `enumerable: false`, preventing properties from appearing in `for...in` loops while remaining accessible.",
        "example": "let obj = {}; Object.defineProperties(obj, { a: { value: 1, enumerable: false } }); for (let key in obj) { console.log(key); } // no output"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Calling `.toPrecision()` with an argument less than 1 or greater than 100 throws a `RangeError`.",
        "answer": true,
        "explanation": "The `.toPrecision()` method requires its precision argument to be between 1 and 100; values outside this range cause a `RangeError`.",
        "example": "let num = 123.456; console.log(num.toPrecision(101)); // RangeError"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Converting a string to a boolean with `Boolean()` treats an empty string as falsy and a whitespace string as truthy.",
        "answer": true,
        "explanation": "An empty string (`''`) is falsy, while any non-empty string, including whitespace (`' '`), is truthy when converted with `Boolean()`.",
        "example": "console.log(Boolean(''), Boolean(' ')); // false, true"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Calling `.reduce()` on an empty array without an initial value throws a `TypeError`.",
        "answer": true,
        "explanation": "Without an initial value, `.reduce()` expects at least one element; an empty array causes a `TypeError` as there's no accumulator to start with.",
        "example": "let arr = []; arr.reduce((acc, val) => acc + val); // TypeError"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `String.prototype.normalize()` method can change a string’s length when converting between Unicode normalization forms.",
        "answer": true,
        "explanation": "`.normalize()` can combine or decompose Unicode characters (e.g., NFC vs. NFD), altering the string’s length based on the normalization form.",
        "example": "let str = 'é'; console.log(str.normalize('NFC').length, str.normalize('NFD').length); // 1, 2"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Properties inherited via `Object.create()` are included in `for...in` loops if they are enumerable in the prototype.",
        "answer": true,
        "explanation": "Enumerable properties in the prototype chain are iterated over by `for...in`, as long as they are marked `enumerable: true`.",
        "example": "let proto = { a: 1 }; Object.defineProperty(proto, 'a', { enumerable: true }); let obj = Object.create(proto); for (let key in obj) { console.log(key); } // 'a'"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `.flatMap()` method is more efficient than chaining `.map()` and `.flat()` for deeply nested arrays.",
        "answer": true,
        "explanation": "`.flatMap()` combines mapping and flattening in one pass, reducing overhead compared to separate `.map()` and `.flat()` operations.",
        "example": "let arr = [1, 2]; console.log(arr.flatMap(x => [x, x * 2])); // [1, 2, 2, 4]"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `typeof` operator returns 'number' for both `NaN` and `Infinity`.",
        "answer": true,
        "explanation": "In JavaScript, `NaN` and `Infinity` are of type `number`, so `typeof NaN` and `typeof Infinity` return 'number'.",
        "example": "console.log(typeof NaN, typeof Infinity); // 'number', 'number'"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`Object.is()` distinguishes between `0` and `-0`, unlike the `===` operator.",
        "answer": true,
        "explanation": "`Object.is()` treats `0` and `-0` as distinct values, while `===` considers them equal due to JavaScript’s equality coercion.",
        "example": "console.log(Object.is(0, -0), 0 === -0); // false, true"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `String.prototype.match()` method returns `null` when no matches are found with a regular expression.",
        "answer": true,
        "explanation": "`.match()` returns `null` if the regular expression finds no matches, rather than an empty array.",
        "example": "let str = 'hello'; console.log(str.match(/x/)); // null"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `.splice()` method always returns an array, even if no elements are removed.",
        "answer": true,
        "explanation": "`.splice()` returns an array of removed elements, which is empty if no elements are removed, never returning `undefined`.",
        "example": "let arr = [1, 2]; console.log(arr.splice(1, 0, 'a')); // []"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`Object.getOwnPropertySymbols()` retrieves `Symbol` properties directly defined on an object.",
        "answer": true,
        "explanation": "`Object.getOwnPropertySymbols()` returns an array of `Symbol` keys defined directly on the object, ignoring string-based properties.",
        "example": "let sym = Symbol('id'); let obj = { [sym]: 1 }; console.log(Object.getOwnPropertySymbols(obj).length); // 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Overriding `.toString()` on a `Number` object can cause `.toString()` to return unexpected results.",
        "answer": true,
        "explanation": "If `.toString()` is overridden on a `Number` object, it may not return the number’s string representation, leading to custom or unexpected output.",
        "example": "let num = new Number(42); num.toString = () => 'custom'; console.log(num.toString()); // 'custom'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let x; { let x = 1; { x = 2; } console.log(x); } console.log(x);`?",
        "options": {
          "1": "2, undefined",
          "2": "1, undefined",
          "3": "2, 1",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `let x` in the outer block creates a block-scoped variable. The assignment `x = 2` in the nested block modifies it. Outside, the global `x` is `undefined`.",
        "example": "let x; { let x = 1; { x = 2; } console.log(x); } console.log(x); // 2, undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let str = 'café'; console.log(str.normalize('NFD').length);` return?",
        "options": {
          "1": "4",
          "2": "5",
          "3": "6",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "The string 'café' has 4 characters, but NFD normalization decomposes 'é' into 'e' and an accent, resulting in 5 code units.",
        "example": "let str = 'café'; console.log(str.normalize('NFD').length); // 5"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let obj = Object.create({ a: 1 }, { b: { value: 2, writable: false } }); console.log(obj.b = 3, obj.b);`?",
        "options": {
          "1": "3, 2",
          "2": "2, 2",
          "3": "3, 3",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The property `b` is non-writable (`writable: false`). Assigning `obj.b = 3` returns 3 but doesn’t change `b`, which remains 2.",
        "example": "let obj = Object.create({ a: 1 }, { b: { value: 2, writable: false } }); console.log(obj.b = 3, obj.b); // 3, 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let num = 0.1 + 0.2; console.log(Math.fround(num) === 0.3);` return?",
        "options": {
          "1": "true",
          "2": "false",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "`Math.fround()` converts to 32-bit float, but `0.1 + 0.2` yields ~0.30000000000000004, which is not equal to 0.3.",
        "example": "let num = 0.1 + 0.2; console.log(Math.fround(num) === 0.3); // false"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2]; arr.length = 5; arr.fill(0, 2); console.log(arr);`?",
        "options": {
          "1": "[1, 2, 0, 0, 0]",
          "2": "[1, 2, undefined, undefined, undefined]",
          "3": "[1, 2, 0, undefined, undefined]",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Setting `arr.length = 5` creates empty slots. `.fill(0, 2)` fills indices 2 to 4 with 0, resulting in `[1, 2, 0, 0, 0]`.",
        "example": "let arr = [1, 2]; arr.length = 5; arr.fill(0, 2); console.log(arr); // [1, 2, 0, 0, 0]"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let str = 'hello'; console.log(str.match(/(l+)/g));` return?",
        "options": {
          "1": "['ll']",
          "2": "['l', 'l']",
          "3": "null",
          "4": "['ll', 'l']"
        },
        "answer": "1",
        "explanation": "The regex `(l+)/g` captures sequences of one or more 'l's. In 'hello', it matches 'll', returning `['ll']`.",
        "example": "let str = 'hello'; console.log(str.match(/(l+)/g)); // ['ll']"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2, 3]; let result = arr.reduceRight((acc, num) => acc + num, ''); console.log(result);`?",
        "options": {
          "1": "'321'",
          "2": "'123'",
          "3": "6",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.reduceRight()` processes from right to left, concatenating numbers to the initial string `''`, resulting in '3' + '2' + '1' = '321'.",
        "example": "let arr = [1, 2, 3]; let result = arr.reduceRight((acc, num) => acc + num, ''); console.log(result); // '321'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let obj = Object.create(null); Object.defineProperty(obj, Symbol('id'), { value: 1 }); console.log(Object.getOwnPropertySymbols(obj).length);` return?",
        "options": {
          "1": "0",
          "2": "1",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "`Object.defineProperty()` adds a `Symbol('id')` property. `Object.getOwnPropertySymbols()` returns an array with that symbol, so the length is 1.",
        "example": "let obj = Object.create(null); Object.defineProperty(obj, Symbol('id'), { value: 1 }); console.log(Object.getOwnPropertySymbols(obj).length); // 1"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2]; arr[3] = 4; console.log(arr.reduce((acc, num) => acc + num, 0));`?",
        "options": {
          "1": "7",
          "2": "3",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Assigning `arr[3] = 4` creates a sparse array `[1, 2, undefined, 4]`. `.reduce()` skips empty slots, summing 1 + 2 + 4 = 7.",
        "example": "let arr = [1, 2]; arr[3] = 4; console.log(arr.reduce((acc, num) => acc + num, 0)); // 7"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let str = 'hello'; console.log(str.replaceAll('l', () => 'p'));` return?",
        "options": {
          "1": "'heppo'",
          "2": "'helpo'",
          "3": "'heppop'",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.replaceAll()` replaces all 'l's with the result of the function, which returns 'p', yielding 'heppo'.",
        "example": "let str = 'hello'; console.log(str.replaceAll('l', () => 'p')); // 'heppo'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let num = 1e308; console.log(num * 2);`?",
        "options": {
          "1": "Infinity",
          "2": "2e308",
          "3": "NaN",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Multiplying `1e308` by 2 exceeds `Number.MAX_VALUE` (~1.797e308), resulting in `Infinity`.",
        "example": "let num = 1e308; console.log(num * 2); // Infinity"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, [2, [3]]]; console.log(arr.flat(Infinity).length);` return?",
        "options": {
          "1": "3",
          "2": "2",
          "3": "4",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.flat(Infinity)` flattens all nested arrays, resulting in `[1, 2, 3]`, with a length of 3.",
        "example": "let arr = [1, [2, [3]]]; console.log(arr.flat(Infinity).length); // 3"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let obj = { a: 1 }; Object.defineProperty(obj, 'a', { value: 2, configurable: false }); delete obj.a; console.log(obj.a);`?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "Setting `configurable: false` prevents deletion of `a`. The value is updated to 2, and `delete` has no effect, so `obj.a` is 2.",
        "example": "let obj = { a: 1 }; Object.defineProperty(obj, 'a', { value: 2, configurable: false }); delete obj.a; console.log(obj.a); // 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, 2, 3]; console.log(arr.copyWithin(1, 0, 2));` return?",
        "options": {
          "1": "[1, 1, 2]",
          "2": "[1, 2, 3]",
          "3": "[1, 1, 3]",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.copyWithin(1, 0, 2)` copies elements from indices 0 to 1 to start at index 1, resulting in `[1, 1, 2]`.",
        "example": "let arr = [1, 2, 3]; console.log(arr.copyWithin(1, 0, 2)); // [1, 1, 2]"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let str = 'hello'; console.log(str.codePointAt(0));` return?",
        "options": {
          "1": "104",
          "2": "72",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.codePointAt(0)` returns the Unicode code point of 'h', which is 104.",
        "example": "let str = 'hello'; console.log(str.codePointAt(0)); // 104"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, 2, 3]; console.log(arr.findLast(num => num < 3));` return?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "3",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "`.findLast()` returns the last element satisfying `< 3`, which is 2, iterating from right to left.",
        "example": "let arr = [1, 2, 3]; console.log(arr.findLast(num => num < 3)); // 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let num = 123.456; console.log(Number.parseFloat(num.toFixed(2)));`?",
        "options": {
          "1": "123.46",
          "2": "123.45",
          "3": "123.456",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.toFixed(2)` rounds to '123.46' as a string. `Number.parseFloat()` converts it back to the number 123.46.",
        "example": "let num = 123.456; console.log(Number.parseFloat(num.toFixed(2))); // 123.46"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let obj = { [Symbol.toPrimitive]() { return 42; } }; console.log(+obj);` return?",
        "options": {
          "1": "42",
          "2": "NaN",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `[Symbol.toPrimitive]` method defines the object’s primitive value, returning 42 when the unary `+` operator is applied.",
        "example": "let obj = { [Symbol.toPrimitive]() { return 42; } }; console.log(+obj); // 42"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2, 3]; arr[Symbol.iterator] = null; console.log([...arr]);`?",
        "options": {
          "1": "[1, 2, 3]",
          "2": "[]",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "4",
        "explanation": "Setting `arr[Symbol.iterator] = null` removes the array’s default iterator, causing a `TypeError` when the spread operator (`...`) is used.",
        "example": "let arr = [1, 2, 3]; arr[Symbol.iterator] = null; console.log([...arr]); // TypeError"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let str = 'hello'; console.log(str.replace(/(l)/g, '$1$1'));` return?",
        "options": {
          "1": "'heelloo'",
          "2": "'hhello'",
          "3": "'ll'",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The regex `(l)/g` captures each 'l', and `$1$1` replaces each 'l' with two 'l's, resulting in 'heelloo'.",
        "example": "let str = 'hello'; console.log(str.replace(/(l)/g, '$1$1')); // 'heelloo'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2, 3]; console.log(arr.at(-2));`?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "3",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The `.at(-2)` method accesses the element at index 1 (length - 2), returning 2.",
        "example": "let arr = [1, 2, 3]; console.log(arr.at(-2)); // 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let obj = { a: 1 }; Object.preventExtensions(obj); obj.b = 2; console.log(obj.b);` return?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "3",
        "explanation": "`Object.preventExtensions()` prevents adding new properties. Assigning `obj.b = 2` has no effect, and `obj.b` is `undefined`.",
        "example": "let obj = { a: 1 }; Object.preventExtensions(obj); obj.b = 2; console.log(obj.b); // undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let num = 42; console.log(num.toLocaleString('en-US', { style: 'currency', currency: 'USD' }));`?",
        "options": {
          "1": "$42.00",
          "2": "42",
          "3": "USD 42",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.toLocaleString('en-US', { style: 'currency', currency: 'USD' })` formats the number as US currency, resulting in '$42.00'.",
        "example": "let num = 42; console.log(num.toLocaleString('en-US', { style: 'currency', currency: 'USD' })); // '$42.00'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, 2, 3, 4]; console.log(arr.pop());` return?",
        "options": {
          "1": "1",
          "2": "4",
          "3": "[1, 2, 3]",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The `pop()` method removes and returns the last element of an array, which is 4. The array becomes [1, 2, 3].",
        "example": "let arr = [1, 2, 3, 4]; console.log(arr.pop()); console.log(arr); // 4, [1, 2, 3]"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the result of `let arr = [1, 2, 3, 4]; console.log(arr.slice(1, 3));`?",
        "options": {
          "1": "[1, 2]",
          "2": "[2, 3]",
          "3": "[2, 3, 4]",
          "4": "[1, 2, 3]"
        },
        "answer": "2",
        "explanation": "The `slice(1, 3)` method returns a new array containing elements from index 1 up to, but not including, index 3, resulting in [2, 3].",
        "example": "let arr = [1, 2, 3, 4]; console.log(arr.slice(1, 3)); console.log(arr); // [2, 3], [1, 2, 3, 4]"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, 2, 3]; console.log(arr.map(x => x * 2));` return?",
        "options": {
          "1": "[2, 4, 6]",
          "2": "[1, 2, 3]",
          "3": "undefined",
          "4": "[1, 4, 9]"
        },
        "answer": "1",
        "explanation": "The `map()` method creates a new array with the results of the callback function applied to each element, doubling each value to [2, 4, 6].",
        "example": "let arr = [1, 2, 3]; console.log(arr.map(x => x * 2)); console.log(arr); // [2, 4, 6], [1, 2, 3]"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Modifying an array declared with `const` will throw an error because the array is immutable.",
        "answer": false,
        "explanation": "A `const` array cannot be reassigned, but its elements can be modified since arrays are mutable objects.",
        "example": "const arr = [1, 2, 3]; arr[0] = 10; console.log(arr); // [10, 2, 3]"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Sparse arrays in JavaScript do not allocate memory for undefined indices.",
        "answer": true,
        "explanation": "Sparse arrays have empty slots that do not allocate memory, unlike defined indices, which store values.",
        "example": "let arr = []; arr[5] = 'x'; console.log(arr.length, arr[3]); // 6, undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the result of `let arr = [1, 2, 3]; console.log(arr.filter(x => x > 1));`?",
        "options": {
          "1": "[1]",
          "2": "[2, 3]",
          "3": "[1, 2, 3]",
          "4": "[]"
        },
        "answer": "2",
        "explanation": "The `filter()` method creates a new array with elements that pass the test in the callback, keeping values greater than 1: [2, 3].",
        "example": "let arr = [1, 2, 3]; console.log(arr.filter(x => x > 1)); console.log(arr); // [2, 3], [1, 2, 3]"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, 2, 3]; console.log(arr.reduce((acc, x) => acc + x, 0));` return?",
        "options": {
          "1": "6",
          "2": "1",
          "3": "[1, 2, 3]",
          "4": "undefined"
        },
        "answer": "1",
        "explanation": "The `reduce()` method applies the callback to accumulate all elements, starting with 0, resulting in 1 + 2 + 3 = 6.",
        "example": "let arr = [1, 2, 3]; console.log(arr.reduce((acc, x) => acc + x, 0)); // 6"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the result of `let arr = [5, 10, 15]; console.log(arr.find(x => x > 10));`?",
        "options": {
          "1": "5",
          "2": "10",
          "3": "15",
          "4": "undefined"
        },
        "answer": "3",
        "explanation": "The `find()` method returns the first element that satisfies the callback, which is 15 since it’s the first value greater than 10.",
        "example": "let arr = [5, 10, 15]; console.log(arr.find(x => x > 10)); // 15"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, 2, 3]; console.log(arr.some(x => x > 2));` return?",
        "options": {
          "1": "true",
          "2": "false",
          "3": "[3]",
          "4": "undefined"
        },
        "answer": "1",
        "explanation": "The `some()` method returns `true` if at least one element passes the callback test, which is true for 3 > 2.",
        "example": "let arr = [1, 2, 3]; console.log(arr.some(x => x > 2)); // true"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `.forEach()` method can modify the original array if the callback function alters its elements.",
        "answer": true,
        "explanation": "The `forEach()` method executes a callback for each element, and if the callback modifies the array’s elements, those changes persist.",
        "example": "let arr = [1, 2, 3]; arr.forEach((x, i) => arr[i] = x * 2); console.log(arr); // [2, 4, 6]"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the result of `let arr = [1, 2, 3]; let copy = arr; copy[0] = 10; console.log(arr);`?",
        "options": {
          "1": "[1, 2, 3]",
          "2": "[10, 2, 3]",
          "3": "[]",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "Assigning an array to a new variable creates a reference. Modifying `copy[0]` changes `arr[0]`, as both point to the same array.",
        "example": "let arr = [1, 2, 3]; let copy = arr; copy[0] = 10; console.log(arr); // [10, 2, 3]"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [[1, 2], [3, 4]]; console.log(arr[1][0]);` return?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "3",
          "4": "4"
        },
        "answer": "3",
        "explanation": "The expression `arr[1][0]` accesses the first element of the second subarray ([3, 4]), which is 3.",
        "example": "let arr = [[1, 2], [3, 4]]; console.log(arr[1][0]); // 3"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the result of `let arr = []; arr[5] = 'x'; console.log(arr.length);`?",
        "options": {
          "1": "0",
          "2": "1",
          "3": "5",
          "4": "6"
        },
        "answer": "4",
        "explanation": "Setting `arr[5] = 'x'` creates a sparse array with length 6 (indices 0 to 5), as the length is one more than the highest index.",
        "example": "let arr = []; arr[5] = 'x'; console.log(arr.length); // 6"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, 2, 3]; console.log(arr.toSpliced(1, 1, 4));` return?",
        "options": {
          "1": "[1, 4, 3]",
          "2": "[1, 2, 3]",
          "3": "[2]",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.toSpliced(1, 1, 4)` is a non-mutating method that returns a new array with the element at index 1 replaced by 4, yielding `[1, 4, 3]`.",
        "example": "let arr = [1, 2, 3]; console.log(arr.toSpliced(1, 1, 4)); // [1, 4, 3]"
      }
    ]
  }
  ]
};

        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let userAnswers = [];

        function startQuiz() {
            const level = document.getElementById('level').value;
            if (!level) return;

            // Reset quiz state
            currentQuestions = [];
            currentQuestionIndex = 0;
            score = 0;
            userAnswers = [];
            document.getElementById('results').style.display = 'none';
            document.getElementById('restart-btn').style.display = 'none';
            document.getElementById('quiz-container').style.display = 'block';
            document.getElementById('feedback-result').textContent = '';
            document.getElementById('feedback-explanation').textContent = '';
            document.getElementById('feedback-example').textContent = '';
            document.getElementById('next-btn').style.display = 'none';

            // Collect and shuffle questions for selected level
            for (let key in quizData) {
                quizData[key].forEach(q => {
                    if (q.level === level) {
                        currentQuestions.push(q);
                    }
                });
            }

            // Shuffle questions to vary order
            currentQuestions = shuffleArray(currentQuestions);

            if (currentQuestions.length === 0) {
                alert('No questions available for this level.');
                document.getElementById('quiz-container').style.display = 'none';
                return;
            }

            displayQuestion();
        }

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function displayQuestion() {
            if (currentQuestionIndex >= currentQuestions.length) {
                showResults();
                return;
            }

            const questionData = currentQuestions[currentQuestionIndex].question[0];
            const questionElement = document.getElementById('question');
            const answersElement = document.getElementById('answers');
            const feedbackResult = document.getElementById('feedback-result');
            const feedbackExplanation = document.getElementById('feedback-explanation');
            const feedbackExample = document.getElementById('feedback-example');
            const nextButton = document.getElementById('next-btn');

            questionElement.textContent = `${currentQuestionIndex + 1}. ${questionData.question}`;
            answersElement.innerHTML = '';
            feedbackResult.textContent = '';
            feedbackExplanation.textContent = '';
            feedbackExample.textContent = '';
            nextButton.style.display = 'none';

            if (currentQuestions[currentQuestionIndex].type === 1) {
                // True/False question
                answersElement.innerHTML = `
                    <button class="true-false-btn true-btn" onclick="selectAnswer(true)">True</button>
                    <button class="true-false-btn false-btn" onclick="selectAnswer(false)">False</button>
                `;
            } else {
                // Multiple-choice question with randomized options
                const options = Object.entries(questionData.options);
                const shuffledOptions = shuffleArray([...options]);

                shuffledOptions.forEach(([key, value]) => {
                    answersElement.innerHTML += `
                        <div class="answer-option">
                            <input type="radio" name="answer" value="${key}" id="option${key}" onchange="selectAnswer(this.value)">
                            <label for="option${key}">${value}</label>
                        </div>
                    `;
                });
            }
        }

        function selectAnswer(answer) {
            const questionData = currentQuestions[currentQuestionIndex].question[0];
            const feedbackResult = document.getElementById('feedback-result');
            const feedbackExplanation = document.getElementById('feedback-explanation');
            const feedbackExample = document.getElementById('feedback-example');
            const nextButton = document.getElementById('next-btn');
            const trueBtn = document.querySelector('.true-btn');
            const falseBtn = document.querySelector('.false-btn');
            const radioButtons = document.querySelectorAll('input[name="answer"]');

            // Store user answer
            userAnswers[currentQuestionIndex] = answer;

            // Check if answer is correct
            const correctAnswer = questionData.answer;
            const isCorrect = answer == correctAnswer;// Use == to handle string vs boolean comparison
            if (isCorrect) {
                score++;
                feedbackResult.textContent = 'Correct!';
                feedbackResult.className = 'correct';
            } else {
                feedbackResult.textContent = `Incorrect! The correct answer is: ${
                    currentQuestions[currentQuestionIndex].type === 1 ? correctAnswer : questionData.options[correctAnswer]
                }`;
                feedbackResult.className = 'incorrect';
            }

            // Display explanation and example
            feedbackExplanation.textContent = `Explanation: ${questionData.explanation}`;
            feedbackExample.textContent = `Example: ${questionData.example}`;

            // Disable answer options to prevent multiple submissions
            if (trueBtn && falseBtn) {
                trueBtn.classList.add('disabled-btn');
                falseBtn.classList.add('disabled-btn');
                trueBtn.disabled = true;
                falseBtn.disabled = true;
            }
            radioButtons.forEach(radio => radio.disabled = true);

            // Show next button
            nextButton.style.display = 'block';
        }

        function nextQuestion() {
            currentQuestionIndex++;
            displayQuestion();
        }

        function showResults() {
            document.getElementById('quiz-container').style.display = 'none';
            const resultsElement = document.getElementById('results');
            resultsElement.style.display = 'block';
            document.getElementById('restart-btn').style.display = 'block';

            let resultHTML = `<h2>Results: ${score}/${currentQuestions.length}</h2>`;
            currentQuestions.forEach((q, index) => {
                const questionData = q.question[0];
                const userAnswer = userAnswers[index];
                const correctAnswer = questionData.answer;
                const isCorrect = userAnswer == correctAnswer;

                resultHTML += `
                    <p>
                        ${index + 1}. ${questionData.question}<br>
                        Your answer: <span class="${isCorrect ? 'correct' : 'incorrect'}">
                            ${q.type === 1 ? userAnswer : (userAnswer ? questionData.options[userAnswer] : 'No answer')}
                        </span><br>
                        Correct answer: <span class="correct">
                            ${q.type === 1 ? correctAnswer : questionData.options[correctAnswer]}
                        </span><br>
                        Explanation: ${questionData.explanation}<br>
                        Example: <span style="font-family: monospace;">${questionData.example}</span>
                    </p>
                `;
            });

            resultsElement.innerHTML = resultHTML;
        }

        function restartQuiz() {
            document.getElementById('level').value = '';
            document.getElementById('quiz-container').style.display = 'none';
            document.getElementById('results').style.display = 'none';
            document.getElementById('restart-btn').style.display = 'none';
            currentQuestions = [];
            currentQuestionIndex = 0;
            score = 0;
            userAnswers = [];
        }
    </script>
</body>
</html>