<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Quiz with Instant Feedback</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f4f4f9;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        #level-selector {
            margin-bottom: 20px;
            text-align: center;
        }
        #level-selector select {
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        #quiz-container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            overflow-wrap: break-word;
        }
        #question {
            font-size: 18px;
            margin-bottom: 20px;
            color: #333;
        }
        .answer-option {
            margin: 10px 0;
            font-size: 16px;
        }
        .answer-option input[type="radio"] {
            margin-right: 10px;
        }
        .true-false-btn {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .true-btn {
            background-color: #4caf50;
            color: white;
        }
        .false-btn {
            background-color: #f44336;
            color: white;
        }
        .true-btn:hover, .false-btn:hover {
            opacity: 0.9;
        }
        .disabled-btn {
            background-color: #ccc !important;
            cursor: not-allowed;
        }
        #feedback {
            margin-top: 15px;
            font-size: 16px;
        }
        #feedback-result {
            font-weight: bold;
        }
        #feedback-explanation, #feedback-example {
            margin-top: 10px;
            font-size: 14px;
            color: #333;
        }
        #feedback-example {
            font-family: monospace;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
        }
        .correct {
            color: #4caf50;
        }
        .incorrect {
            color: #f44336;
        }
        #next-btn {
            display: none;
            margin: 20px auto;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        #next-btn:hover {
            background-color: #0056b3;
        }
        #results {
            margin-top: 20px;
            padding: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
        }
        #restart-btn {
            display: none;
            margin: 20px auto;
            padding: 10px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        #restart-btn:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>
    <h1>JavaScript Quiz with Instant Feedback</h1>
    <div id="level-selector">
        <label for="level">Select Difficulty Level: </label>
        <select id="level" onchange="startQuiz()">
            <option value="">Select a level</option>
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
        </select>
    </div>
    <div id="quiz-container" style="display: none;">
        <div id="question"></div>
        <div id="answers"></div>
        <div id="feedback">
            <div id="feedback-result"></div>
            <div id="feedback-explanation"></div>
            <div id="feedback-example"></div>
        </div>
        <button id="next-btn" onclick="nextQuestion()">Next Question</button>
    </div>
    <div id="results" style="display: none;"></div>
    <button id="restart-btn" style="display: none;" onclick="restartQuiz()">Restart Quiz</button>

    <script>
        
        const quizData = {
  "1": [
    {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of calling toString() on an object created with Object Literal syntax?",
        "options": {
          "1": "[object Object]",
          "2": "undefined",
          "3": "Object Literal",
          "4": "null"
        },
        "answer": "1",
        "explanation": "Objects created with Object Literal syntax inherit from Object.prototype, which provides the toString() method returning '[object Object]' by default.",
        "example": "let obj = { name: 'Luiz' };\nconsole.log(obj.toString()); // '[object Object]'"
      }
    ]
    },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "Which method checks if a property is an own property of an object, not inherited from its prototype?",
        "options": {
          "1": "Object.getPrototypeOf()",
          "2": "hasOwnProperty()",
          "3": "toString()",
          "4": "Object.setPrototypeOf()"
        },
        "answer": "2",
        "explanation": "hasOwnProperty() is a method on Object.prototype that checks if a property exists directly on the object, not inherited via the prototype chain.",
        "example": "let obj = { name: 'Luiz' };\nconsole.log(obj.hasOwnProperty('name')); // true\nconsole.log(obj.hasOwnProperty('toString')); // false"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the prototype of an object created with new Object()?",
        "options": {
          "1": "null",
          "2": "Object.prototype",
          "3": "Function.prototype",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "Objects created with new Object() inherit from Object.prototype, which provides methods like toString() and hasOwnProperty().",
        "example": "let obj = new Object();\nconsole.log(Object.getPrototypeOf(obj) === Object.prototype); // true"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does Object.getPrototypeOf() return for an object created with Object.create(null)?",
        "options": {
          "1": "Object.prototype",
          "2": "null",
          "3": "Function.prototype",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "Object.create(null) creates an object with no prototype, so Object.getPrototypeOf() returns null.",
        "example": "let obj = Object.create(null);\nconsole.log(Object.getPrototypeOf(obj)); // null"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of accessing a non-existent property on an object created with Object Literal syntax?",
        "options": {
          "1": "null",
          "2": "undefined",
          "3": "throws an error",
          "4": "empty string"
        },
        "answer": "2",
        "explanation": "Accessing a non-existent property on an object returns undefined, as the prototype chain is traversed until null is reached.",
        "example": "let obj = { name: 'Luiz' };\nconsole.log(obj.age); // undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "Which syntax defines a method on a Constructor Function’s prototype?",
        "options": {
          "1": "function Person() { this.greet = () => 'Hi!'; }",
          "2": "Person.prototype.greet = function() { return 'Hi!'; };",
          "3": "let obj = new Person(); obj.greet = () => 'Hi!';",
          "4": "Person.greet = function() { return 'Hi!'; };"
        },
        "answer": "2",
        "explanation": "Person.prototype.greet adds a method to the prototype, shared by all instances. Option 1 adds it to each instance, option 3 to a single instance, and option 4 to the constructor function itself.",
        "example": "function Person() {}\nPerson.prototype.greet = function() { return 'Hi!'; };\nlet p = new Person();\nconsole.log(p.greet()); // 'Hi!'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the prototype of an instance created with a Class Syntax constructor?",
        "options": {
          "1": "Class.prototype",
          "2": "Object.prototype",
          "3": "Function.prototype",
          "4": "null"
        },
        "answer": "1",
        "explanation": "Instances created with Class Syntax inherit from the class’s prototype (e.g., Person.prototype), not directly from Object.prototype or Function.prototype.",
        "example": "class Person {}\nlet p = new Person();\nconsole.log(Object.getPrototypeOf(p) === Person.prototype); // true"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does the following code log: let obj = Object.create({ name: 'Luiz' }); console.log(obj.name);?",
        "options": {
          "1": "Luiz",
          "2": "undefined",
          "3": "null",
          "4": "throws an error"
        },
        "answer": "1",
        "explanation": "Object.create() sets the specified object as the prototype, so obj.name accesses the inherited name property from the prototype.",
        "example": "let obj = Object.create({ name: 'Luiz' });\nconsole.log(obj.name); // 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of calling hasOwnProperty('toString') on an Object Literal?",
        "options": {
          "1": "true",
          "2": "false",
          "3": "undefined",
          "4": "null"
        },
        "answer": "2",
        "explanation": "toString is inherited from Object.prototype, not an own property, so hasOwnProperty('toString') returns false.",
        "example": "let obj = {};\nconsole.log(obj.hasOwnProperty('toString')); // false"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does the following Factory Function return: function createPerson(name) { return { name }; }?",
        "options": {
          "1": "An object with Object.prototype as its prototype",
          "2": "An object with Function.prototype as its prototype",
          "3": "An object with no prototype",
          "4": "A function"
        },
        "answer": "1",
        "explanation": "Factory Functions return objects that inherit from Object.prototype by default unless customized.",
        "example": "function createPerson(name) { return { name }; }\nlet p = createPerson('Luiz');\nconsole.log(Object.getPrototypeOf(p) === Object.prototype); // true"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the prototype of a Constructor Function itself?",
        "options": {
          "1": "Object.prototype",
          "2": "Function.prototype",
          "3": "null",
          "4": "Person.prototype"
        },
        "answer": "2",
        "explanation": "Constructor Functions are functions, so they inherit from Function.prototype, which chains to Object.prototype.",
        "example": "function Person() {}\nconsole.log(Object.getPrototypeOf(Person) === Function.prototype); // true"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does the following code log: class Person { greet() { return 'Hi!'; } } let p = new Person(); console.log(p.greet());?",
        "options": {
          "1": "Hi!",
          "2": "undefined",
          "3": "throws an error",
          "4": "null"
        },
        "answer": "1",
        "explanation": "The greet method is defined on Person.prototype and inherited by the instance p, so p.greet() returns 'Hi!'.",
        "example": "class Person {\n  greet() { return 'Hi!'; }\n}\nlet p = new Person();\nconsole.log(p.greet()); // 'Hi!'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of adding a property to Person.prototype and accessing it from an instance?",
        "options": {
          "1": "The property is accessible",
          "2": "The property is undefined",
          "3": "Throws an error",
          "4": "The property is null"
        },
        "answer": "1",
        "explanation": "Properties added to Person.prototype are inherited by all instances of Person, making them accessible.",
        "example": "function Person() {}\nPerson.prototype.role = 'Student';\nlet p = new Person();\nconsole.log(p.role); // 'Student'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does Object.getPrototypeOf({}) return?",
        "options": {
          "1": "Object.prototype",
          "2": "null",
          "3": "Function.prototype",
          "4": "undefined"
        },
        "answer": "1",
        "explanation": "Objects created with Object Literal syntax ({}) inherit from Object.prototype.",
        "example": "let obj = {};\nconsole.log(Object.getPrototypeOf(obj) === Object.prototype); // true"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the result of calling a method defined on a Constructor Function’s prototype?",
        "options": {
          "1": "The method executes",
          "2": "undefined",
          "3": "Throws an error",
          "4": "null"
        },
        "answer": "1",
        "explanation": "Methods defined on a Constructor Function’s prototype are inherited by instances and can be called.",
        "example": "function Person() {}\nPerson.prototype.greet = function() { return 'Hello!'; };\nlet p = new Person();\nconsole.log(p.greet()); // 'Hello!'"
      }
    ]
  },
      {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "An object created with object literal syntax using `{}` is immediately usable without requiring a constructor.",
        "answer": true,
        "explanation": "Object literal syntax `{}` creates an object directly, allowing immediate property and method assignments without a constructor function.",
        "example": "let obj = { name: 'Luiz' }; console.log(obj.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "A `const` object cannot have its properties modified.",
        "answer": false,
        "explanation": "A `const` object prevents reassignment of the object reference, but its properties can still be modified as objects are mutable.",
        "example": "const obj = { name: 'Luiz' }; obj.name = 'Marta'; console.log(obj.name); \n// 'Marta'"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "The `new Object()` constructor creates an empty object by default.",
        "answer": true,
        "explanation": "The `new Object()` constructor creates an empty object, which can then have properties and methods assigned to it.",
        "example": "let obj = new Object(); console.log(Object.keys(obj)); \n// []"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "Factory Functions return a new object each time they are called.",
        "answer": true,
        "explanation": "Factory Functions return a new object with the specified structure every time they are invoked, without relying on `this` or prototypes.",
        "example": "function createObj() { return { name: 'Luiz' }; } console.log(createObj().name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 1,
    "level": "easy",
    "question": [
      {
        "question": "The Class Syntax in JavaScript requires a `constructor` method to initialize properties.",
        "answer": false,
        "explanation": "While a `constructor` is commonly used in Class Syntax, it is not required; properties can be defined directly in the class body or methods.",
        "example": "class Person { name = 'Luiz'; } let p = new Person(); console.log(p.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let obj = { name: 'Luiz' }; console.log(obj.name);`?",
        "options": {
          "1": "'Luiz'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The object literal `{ name: 'Luiz' }` defines a property `name`, which is accessed using dot notation, returning 'Luiz'.",
        "example": "let obj = { name: 'Luiz' }; console.log(obj.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does `let obj = new Object(); obj.name = 'Luiz'; console.log(obj.name);` return?",
        "options": {
          "1": "'Luiz'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`new Object()` creates an empty object, and assigning `obj.name = 'Luiz'` adds the `name` property, which is then accessed.",
        "example": "let obj = new Object(); obj.name = 'Luiz'; console.log(obj.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `function createObj() { return { name: 'Luiz' }; } let obj = createObj(); console.log(obj.name);`?",
        "options": {
          "1": "'Luiz'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The Factory Function `createObj` returns a new object with a `name` property, which is accessed as `obj.name`.",
        "example": "function createObj() { return { name: 'Luiz' }; } let obj = createObj(); console.log(obj.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What does `class Person { constructor(name) { this.name = name; } } let p = new Person('Luiz'); console.log(p.name);` return?",
        "options": {
          "1": "'Luiz'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `Person` class constructor sets the `name` property, which is accessed on the instance `p`.",
        "example": "class Person { constructor(name) { this.name = name; } } let p = new Person('Luiz'); console.log(p.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "easy",
    "question": [
      {
        "question": "What is the output of `let proto = { greet: () => 'Hi' }; let obj = Object.create(proto); console.log(obj.greet());`?",
        "options": {
          "1": "'Hi'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`Object.create(proto)` creates an object with `proto` as its prototype, inheriting the `greet` method, which returns 'Hi'.",
        "example": "let proto = { greet: () => 'Hi' }; let obj = Object.create(proto); console.log(obj.greet()); \n// 'Hi'"
      }
    ]
  },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Objects in JavaScript are unordered collections of key-value pairs.",
          "answer": true,
          "explanation": "Objects in JavaScript are indeed unordered collections of key-value pairs, where keys are typically strings or symbols, and values can be any data type. Unlike arrays, objects do not maintain a specific order for their properties.",
          "example": "let obj = { name: 'Luiz', age: 29 }; \nconsole.log(obj); \n// { name: 'Luiz', age: 29 } (order may vary)"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Object keys in JavaScript can only be strings.",
          "answer": false,
          "explanation": "Object keys can be strings or symbols. While strings are the most common, symbols can also be used as unique property keys since ES6.",
          "example": "let sym = Symbol('key'); \nlet obj = { 'name': 'Luiz', [sym]: 42 }; \nconsole.log(Object.getOwnPropertySymbols(obj)); \n// [Symbol(key)]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "An object declared with `const` cannot have its properties modified.",
          "answer": false,
          "explanation": "Using `const` prevents reassignment of the object reference, but the object's properties can still be modified because objects are mutable by default.",
          "example": "const obj = { name: 'Luiz' }; \nobj.name = 'Marta'; \nconsole.log(obj); \n// { name: 'Marta' }"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Accessing a non-existent property in an object returns `undefined`.",
          "answer": true,
          "explanation": "When a property does not exist in an object, accessing it with dot or bracket notation returns `undefined`.",
          "example": "let obj = { name: 'Luiz' }; \nconsole.log(obj.age); \n// undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `typeof` operator returns 'object' for an object in JavaScript.",
          "answer": true,
          "explanation": "The `typeof` operator returns 'object' for objects, including those created with object literals, constructors, or classes.",
          "example": "let obj = { name: 'Luiz' }; \nconsole.log(typeof obj); \n// 'object'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Objects can be created using the object literal syntax `{}`.",
          "answer": true,
          "explanation": "The object literal syntax `{}` is a common and concise way to create objects in JavaScript.",
          "example": "let obj = {}; \nobj.name = 'Luiz'; \nconsole.log(obj); \n// { name: 'Luiz' }"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Bracket notation `object['key']` can be used to access properties dynamically.",
          "answer": true,
          "explanation": "Bracket notation allows dynamic property access using a string or variable, useful for invalid identifiers or computed property names.",
          "example": "let obj = { color: 'blue' }; \nlet key = 'color'; \nconsole.log(obj[key]); \n// 'blue'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Objects in JavaScript are copied by value when assigned to a new variable.",
          "answer": false,
          "explanation": "Objects are copied by reference, so assigning an object to a new variable points to the same memory location, and changes affect the original.",
          "example": "let obj = { name: 'Luiz' }; \nlet copy = obj; \ncopy.name = 'Marta'; \nconsole.log(obj.name); \n// 'Marta'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `delete` operator can remove any property from an object, including inherited ones.",
          "answer": false,
          "explanation": "The `delete` operator only removes own properties of an object, not inherited properties from its prototype.",
          "example": "let proto = { name: 'Luiz' }; \nlet obj = Object.create(proto); \ndelete obj.name; \nconsole.log(obj.name); \n// 'Luiz' (inherited, not deleted)"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Objects can contain other objects as property values.",
          "answer": true,
          "explanation": "Objects can have nested objects as property values, allowing complex data structures.",
          "example": "let obj = { info: { city: 'New York' } }; \nconsole.log(obj.info.city); \n// 'New York'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Arrays in JavaScript can store elements of different types, such as numbers, strings, and objects.",
          "answer": true,
          "explanation": "Arrays in JavaScript are flexible and can hold elements of any type, including mixed types like numbers, strings, and objects.",
          "example": "let arr = [1, 'hello', { name: 'Luiz' }]; \nconsole.log(arr); \n// [1, 'hello', { name: 'Luiz' }]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `.length` property of an array returns the number of elements, including undefined ones in sparse arrays.",
          "answer": true,
          "explanation": "The `.length` property reflects the highest index plus one, including undefined elements in sparse arrays.",
          "example": "let arr = []; \narr[5] = 'x'; \nconsole.log(arr.length); \n// 6"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Arrays in JavaScript are immutable, meaning their elements cannot be changed directly.",
          "answer": false,
          "explanation": "Arrays are mutable, allowing their elements to be modified directly via index access or methods.",
          "example": "let arr = [1, 2]; \narr[0] = 3; \nconsole.log(arr); \n// [3, 2]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "An empty array has a `.length` of 0.",
          "answer": true,
          "explanation": "An empty array, created with `[]` or `new Array()`, has a `.length` of 0 since it contains no elements.",
          "example": "let arr = []; \nconsole.log(arr.length); \n// 0"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `typeof` operator returns 'array' for an array in JavaScript.",
          "answer": false,
          "explanation": "The `typeof` operator returns 'object' for arrays, as arrays are a type of object in JavaScript.",
          "example": "let arr = [1, 2, 3]; \nconsole.log(typeof arr); \n// 'object'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Arrays in JavaScript can be created using the `Array` constructor.",
          "answer": true,
          "explanation": "Arrays can be created using the `Array` constructor, such as `new Array()` or `Array()`, in addition to the literal syntax `[]`.",
          "example": "let arr = new Array(1, 2, 3); \nconsole.log(arr); \n// [1, 2, 3]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The first element of an array is accessed with index 1.",
          "answer": false,
          "explanation": "JavaScript arrays are zero-indexed, so the first element is accessed with index 0.",
          "example": "let arr = ['a', 'b']; \nconsole.log(arr[0]); \n// 'a'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "An array declared with `const` can have its elements modified.",
          "answer": true,
          "explanation": "Using `const` prevents reassignment of the array, but its elements can be modified because arrays are mutable.",
          "example": "const arr = [1, 2]; \narr[0] = 3; \nconsole.log(arr); \n// [3, 2]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Accessing an array with an index that does not exist returns `undefined`.",
          "answer": true,
          "explanation": "Accessing an array index that is out of bounds or undefined returns `undefined`.",
          "example": "let arr = [1, 2]; \nconsole.log(arr[5]); \n// undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Arrays in JavaScript are always stored as copies when assigned to a new variable.",
          "answer": false,
          "explanation": "Arrays are copied by reference, so assigning an array to a new variable points to the same memory location.",
          "example": "let arr = [1, 2]; \nlet copy = arr; \ncopy[0] = 3; \nconsole.log(arr); \n// [3, 2]"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Strings in JavaScript can be created using single quotes, double quotes, or template literals.",
          "answer": true,
          "explanation": "Strings can be created with single quotes (`'`), double quotes (`\"`), or template literals (`` ` ``), all producing string primitives.",
          "example": "let s1 = 'hi'; \nlet s2 = \"hello\"; \nlet s3 = `world`; \nconsole.log(typeof s1, typeof s2, typeof s3); \n// 'string' 'string' 'string'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "An empty string has a length of 0.",
          "answer": true,
          "explanation": "An empty string (`''`) has no characters, so its `.length` property returns 0.",
          "example": "let str = ''; \nconsole.log(str.length); \n// 0"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "A string in JavaScript can contain numbers and special symbols like emojis.",
          "answer": true,
          "explanation": "Strings can include numbers, letters, special characters, and emojis, as they are sequences of UTF-16 code units.",
          "example": "let str = '123 😊'; \nconsole.log(str); \n// '123 😊'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Strings in JavaScript are mutable, meaning their original value can be changed directly.",
          "answer": false,
          "explanation": "Strings are immutable in JavaScript; \noperations like concatenation create new strings without modifying the original.",
          "example": "let str = 'hello'; \nstr[0] = 'x'; \nconsole.log(str); \n// 'hello' (unchanged)"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `.length` property of a string returns the number of characters, including spaces.",
          "answer": true,
          "explanation": "The `.length` property counts all characters in a string, including spaces and special characters.",
          "example": "let str = 'hi there'; \nconsole.log(str.length); \n// 8"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Booleans in JavaScript can only have two values: true or false.",
          "answer": true,
          "explanation": "Boolean primitives in JavaScript are strictly `true` or `false`, representing logical truth values.",
          "example": "let bool = true; \nconsole.log(bool); \n// true"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The typeof operator returns 'boolean' for a Boolean value.",
          "answer": true,
          "explanation": "The `typeof` operator returns 'boolean' for both primitive booleans and Boolean objects.",
          "example": "let bool = false; \nconsole.log(typeof bool); \n// 'boolean'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The logical NOT operator (!) inverts a Boolean value.",
          "answer": true,
          "explanation": "The `!` operator negates a boolean, turning `true` to `false` and vice versa.",
          "example": "let bool = true; \nconsole.log(!bool); \n// false"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Booleans can be used in if statements to control program flow.",
          "answer": true,
          "explanation": "Booleans are commonly used in conditional statements like `if` to determine execution paths.",
          "example": "let bool = true; \nif (bool) { console.log('Run'); \n} // 'Run'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "A Boolean primitive has built-in methods like toString() without needing to be an object.",
          "answer": true,
          "explanation": "Due to autoboxing, Boolean primitives can use methods like `toString()` as if they were objects.",
          "example": "let bool = false; \nconsole.log(bool.toString()); \n// 'false'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The Number type in JavaScript can represent both integers and floating-point numbers.",
          "answer": true,
          "explanation": "The Number type in JavaScript includes both integers (e.g., 42) and floating-point numbers (e.g., 3.14).",
          "example": "let num1 = 42; \nlet num2 = 3.14; \nconsole.log(typeof num1, typeof num2); \n// 'number' 'number'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "All numbers in JavaScript are stored as 32-bit integers.",
          "answer": false,
          "explanation": "Numbers in JavaScript are stored as 64-bit floating-point values, per the IEEE 754 standard, not 32-bit integers.",
          "example": "let num = 3.14; \nconsole.log(num); \n// 3.14 (floating-point)"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "You can use scientific notation like `1e5` to represent numbers in JavaScript.",
          "answer": true,
          "explanation": "Scientific notation (e.g., `1e5` for 100000) is supported for representing large or small numbers.",
          "example": "let num = 1e5; \nconsole.log(num); \n// 100000"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "The `typeof` a number primitive in JavaScript is 'number'.",
          "answer": true,
          "explanation": "The `typeof` operator returns 'number' for number primitives, including integers and floats.",
          "example": "let num = 42; \nconsole.log(typeof num); \n// 'number'"
        }
      ]
    },
    {
      "type": 1,
      "level": "easy",
      "question": [
        {
          "question": "Using `new Number(42)` creates a number primitive.",
          "answer": false,
          "explanation": "`new Number(42)` creates a Number object, not a primitive number. Primitive numbers are created directly (e.g., `42`).",
          "example": "let num = new Number(42); \nconsole.log(typeof num); \n// 'object'"
        }
      ]
    }
  ],
  "2": [
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Assigning an array to a new variable creates a reference to the same array in memory.",
          "answer": true
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.slice()` method modifies the original array.",
          "answer": false
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.splice()` method can be used to add elements to an array without removing any.",
          "answer": true
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.at()` method supports negative indices to access elements from the end of an array.",
          "answer": true
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.forEach()` method always returns a new array with the results of the callback function.",
          "answer": false
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.unshift()` method adds elements to the beginning of an array and returns the new length.",
          "answer": true
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.shift()` method removes the last element of an array.",
          "answer": false
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the result of `let arr = [1, 2, 3]; console.log(arr.unshift(0));`?",
          "options": {
            "1": "[0, 1, 2, 3]",
            "2": "4",
            "3": "[1, 2, 3, 0]",
            "4": "0"
          },
          "answer": "2"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What does `let arr = [1, 2, 3]; console.log(arr.shift());` return?",
          "options": {
            "1": "1",
            "2": "3",
            "3": "[2, 3]",
            "4": "undefined"
          },
          "answer": "1"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the result of `let arr = [1, 2, 3, 4]; console.log(arr.slice(-2));`?",
          "options": {
            "1": "[1, 2]",
            "2": "[3, 4]",
            "3": "[2, 3]",
            "4": "[4]"
          },
          "answer": "2"
        }
      ]
    },
    {
  "type": 2,
  "level": "medium",
  "question": [
    {
      "question": "Which of the following correctly lists all primary methods for creating an object in JavaScript along with an example for each?",
      "options": {
        "1": "Object Literal: `let obj = { name: 'Luiz' };`, Object Constructor: `let obj = new Object(); obj.name = 'Luiz';`, Object.create: `let obj = Object.create({ name: 'Luiz' });`, Factory Function: `function createObj() { return { name: 'Luiz' }; }`, Class Syntax: `class Person { constructor(name) { this.name = name; } } let obj = new Person('Luiz');`",
        "2": "Object Literal: `let obj = [];`, Object Constructor: `let obj = new Object();`, Object.create: `let obj = Object.create(null);`, Factory Function: `function createObj() { return new Object(); }`, Class Syntax: `class Person { name = 'Luiz'; }`",
        "3": "Object Literal: `let obj = { name: 'Luiz' };`, Object Constructor: `let obj = Object();`, Object.create: `let obj = Object.create({});`, Factory Function: `function createObj() { return { name: 'Luiz' }; }`, Class Syntax: `class Person { constructor() { name: 'Luiz'; } }`",
        "4": "Object Literal: `let obj = new Object();`, Object Constructor: `let obj = {};`, Object.create: `let obj = Object.create(null); obj.name = 'Luiz';`, Factory Function: `function createObj() { this.name = 'Luiz'; }`, Class Syntax: `class Person { constructor(name) { this.name = name; } }`"
      },
      "answer": "1",
      "explanation": "The primary methods for creating objects in JavaScript are: Object Literal (`{}`), Object Constructor (`new Object()`), Object.create (`Object.create(proto)`), Factory Function (returns an object), and Class Syntax (`class`). Option 1 correctly demonstrates each method with valid syntax and examples, while others contain errors (e.g., incorrect syntax for Object Literal, invalid constructor usage, or missing `this`).",
      "example": "let obj1 = { name: 'Luiz' }; // Object Literal\nlet obj2 = new Object(); obj2.name = 'Luiz'; // Object Constructor\nlet obj3 = Object.create({ name: 'Luiz' }); // Object.create\nfunction createObj() { return { name: 'Luiz' }; } let obj4 = createObj(); // Factory Function\nclass Person { constructor(name) { this.name = name; } } let obj5 = new Person('Luiz'); // Class Syntax\nconsole.log(obj1.name, obj2.name, obj3.name, obj4.name, obj5.name); \n// 'Luiz', 'Luiz', 'Luiz', 'Luiz', 'Luiz'"
    }
  ]
},
     {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "Properties defined in an object literal are automatically enumerable, making them appear in `for...in` loops.",
        "answer": true,
        "explanation": "Object literal properties are enumerable by default, so they are included in `for...in` loops unless explicitly set to `enumerable: false`.",
        "example": "let obj = { name: 'Luiz' }; for (let key in obj) { console.log(key); } \n// 'name'"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "A custom constructor function using `this` allows creating multiple objects with shared methods via the prototype.",
        "answer": true,
        "explanation": "Constructor functions use `this` to assign properties, and methods added to the constructor’s prototype are shared across instances.",
        "example": "function Person(name) { this.name = name; } Person.prototype.greet = function() { return 'Hi'; }; let p = new Person('Luiz'); console.log(p.greet()); \n// 'Hi'"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "`Object.create(null)` creates an object with no prototype, preventing inheritance of `Object.prototype` methods.",
        "answer": true,
        "explanation": "`Object.create(null)` creates an object with no prototype, so it does not inherit methods like `toString()` from `Object.prototype`.",
        "example": "let obj = Object.create(null); console.log(obj.toString); \n// undefined"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "Factory Functions can create private variables using closures, unlike Class Syntax.",
        "answer": true,
        "explanation": "Factory Functions can encapsulate private data via closures, while Class Syntax exposes properties through `this`, making them public.",
        "example": "function createObj() { let secret = 'hidden'; return { getSecret: () => secret }; } let obj = createObj(); console.log(obj.getSecret()); \n// 'hidden'"
      }
    ]
  },
  {
    "type": 1,
    "level": "medium",
    "question": [
      {
        "question": "The `extends` keyword in Class Syntax allows a subclass to inherit methods from a parent class.",
        "answer": true,
        "explanation": "The `extends` keyword enables a subclass to inherit properties and methods from a parent class via the prototype chain.",
        "example": "class Parent { greet() { return 'Hi'; } } class Child extends Parent {} let c = new Child(); console.log(c.greet()); \n// 'Hi'"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `function Person(name) { this.name = name; } let p1 = new Person('Luiz'); let p2 = new Person('Marta'); console.log(p1.name, p2.name);`?",
        "options": {
          "1": "'Luiz', 'Marta'",
          "2": "'Marta', 'Luiz'",
          "3": "undefined, undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The constructor function `Person` assigns the `name` property to each instance, so `p1` and `p2` have their respective names.",
        "example": "function Person(name) { this.name = name; } let p1 = new Person('Luiz'); let p2 = new Person('Marta'); console.log(p1.name, p2.name); \n// 'Luiz', 'Marta'"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What does `let proto = { greet: () => 'Hi' }; let obj = Object.create(proto); console.log(Object.getPrototypeOf(obj) === proto);` return?",
        "options": {
          "1": "true",
          "2": "false",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`Object.create(proto)` sets `proto` as the prototype of `obj`, so `Object.getPrototypeOf(obj)` returns `proto`.",
        "example": "let proto = { greet: () => 'Hi' }; let obj = Object.create(proto); console.log(Object.getPrototypeOf(obj) === proto); \n// true"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `function createObj() { return { name: 'Luiz', getName: function() { return this.name; } }; } let obj = createObj(); console.log(obj.getName());`?",
        "options": {
          "1": "'Luiz'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The Factory Function returns an object with a `getName` method that uses `this` to access the `name` property, returning 'Luiz'.",
        "example": "function createObj() { return { name: 'Luiz', getName: function() { return this.name; } }; } let obj = createObj(); console.log(obj.getName()); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What does `class Person { constructor(name) { this.name = name; } } let p = new Person('Luiz'); console.log(p instanceof Person);` return?",
        "options": {
          "1": "true",
          "2": "false",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `instanceof` operator checks if `Person.prototype` is in `p`’s prototype chain, which is true for an instance created with `new Person`.",
        "example": "class Person { constructor(name) { this.name = name; } } let p = new Person('Luiz'); console.log(p instanceof Person); \n// true"
      }
    ]
  },
  {
    "type": 2,
    "level": "medium",
    "question": [
      {
        "question": "What is the output of `let obj = Object.create({ name: 'Luiz' }); obj.name = 'Marta'; console.log(obj.name, Object.getPrototypeOf(obj).name);`?",
        "options": {
          "1": "'Marta', 'Luiz'",
          "2": "'Luiz', 'Marta'",
          "3": "'Marta', undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Assigning `obj.name = 'Marta'` creates an own property, shadowing the prototype’s `name`. The prototype’s `name` remains 'Luiz'.",
        "example": "let obj = Object.create({ name: 'Luiz' }); obj.name = 'Marta'; console.log(obj.name, Object.getPrototypeOf(obj).name); \n// 'Marta', 'Luiz'"
      }
    ]
  },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Assigning an object to a new variable creates a reference to the same object in memory.",
          "answer": true,
          "explanation": "Objects are reference types, so assigning an object to a new variable copies the reference, not the object itself, affecting the original when modified.",
          "example": "let obj = { a: 1 }; \nlet copy = obj; \ncopy.a = 2; \nconsole.log(obj.a); \n// 2"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `Object.keys()` method modifies the original object.",
          "answer": false,
          "explanation": "`Object.keys()` is non-mutative, returning a new array of the object's enumerable property names without altering the object.",
          "example": "let obj = { a: 1, b: 2 }; \nconsole.log(Object.keys(obj)); \nconsole.log(obj); \n// ['a', 'b'] { a: 1, b: 2 }"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `Object.seal()` method prevents modifications to existing object properties.",
          "answer": false,
          "explanation": "`Object.seal()` prevents adding or deleting properties but allows modifying existing property values.",
          "example": "let obj = { a: 1 }; \nObject.seal(obj); \nobj.a = 2; \nconsole.log(obj.a); \n// 2"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `delete` operator returns `true` when a non-existent property is deleted.",
          "answer": true,
          "explanation": "The `delete` operator returns `true` when attempting to delete a non-existent property, as the operation is considered successful.",
          "example": "let obj = { a: 1 }; \nconsole.log(delete obj.b); \n// true"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `Object.create()` method allows creating objects with a specified prototype.",
          "answer": true,
          "explanation": "`Object.create()` creates a new object with the specified prototype, allowing inheritance of properties and methods.",
          "example": "let proto = { greet: () => 'Hi' }; \nlet obj = Object.create(proto); \nconsole.log(obj.greet()); \n// 'Hi'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Factory functions use prototype inheritance to share methods between objects.",
          "answer": false,
          "explanation": "Factory functions return new objects without using prototypes, creating separate method copies for each object.",
          "example": "function create() { return { greet: () => 'Hi' }; \n} let obj1 = create(); \nlet obj2 = create(); \nconsole.log(obj1.greet === obj2.greet); \n// false"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The spread operator (`...`) creates a deep copy of an object.",
          "answer": false,
          "explanation": "The spread operator creates a shallow copy, copying only top-level properties; \nnested objects remain referenced.",
          "example": "let obj = { a: { b: 1 } }; \nlet copy = { ...obj }; \ncopy.a.b = 2; \nconsole.log(obj.a.b); \n// 2"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the result of `let obj = { a: 1, b: 2 }; \nconsole.log(Object.keys(obj));`?",
          "options": {
            "1": "['a', 'b']",
            "2": "[1, 2]",
            "3": "{ a: 1, b: 2 }",
            "4": "undefined"
          },
          "answer": "1",
          "explanation": "`Object.keys()` returns an array of the object's enumerable property names, in this case, `['a', 'b']`.",
          "example": "let obj = { a: 1, b: 2 }; \nconsole.log(Object.keys(obj)); \n// ['a', 'b']"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What does `let obj = { name: 'Luiz' }; \ndelete obj.name; \nconsole.log(obj);` return?",
          "options": {
            "1": "{ name: 'Luiz' }",
            "2": "{}",
            "3": "undefined",
            "4": "null"
          },
          "answer": "2",
          "explanation": "The `delete` operator removes the `name` property, leaving an empty object `{}`.",
          "example": "let obj = { name: 'Luiz' }; \ndelete obj.name; \nconsole.log(obj); \n// {}"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the result of `let obj = Object.create({ name: 'Luiz' }); \nconsole.log(obj.name);`?",
          "options": {
            "1": "'Luiz'",
            "2": "undefined",
            "3": "null",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "`Object.create()` sets the prototype to the specified object, so `obj.name` accesses the inherited `name` property.",
          "example": "let obj = Object.create({ name: 'Luiz' }); \nconsole.log(obj.name); \n// 'Luiz'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Assigning an array to a new variable creates a reference to the same array in memory.",
          "answer": true,
          "explanation": "Arrays, like objects, are reference types, so assignment copies the reference, not the array itself.",
          "example": "let arr = [1, 2]; \nlet copy = arr; \ncopy[0] = 3; \nconsole.log(arr); \n// [3, 2]"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.slice()` method modifies the original array.",
          "answer": false,
          "explanation": "`.slice()` is non-mutative, returning a new array with the selected elements without altering the original.",
          "example": "let arr = [1, 2, 3]; \nconsole.log(arr.slice(0, 2)); \nconsole.log(arr); \n// [1, 2] [1, 2, 3]"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.splice()` method can be used to add elements to an array without removing any.",
          "answer": true,
          "explanation": "`.splice()` can add elements by specifying a delete count of 0, inserting new elements at the given index.",
          "example": "let arr = [1, 2]; \narr.splice(1, 0, 'a'); \nconsole.log(arr); \n// [1, 'a', 2]"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.at()` method supports negative indices to access elements from the end of an array.",
          "answer": true,
          "explanation": "The `.at()` method, introduced in ES2022, allows negative indices to access elements from the array's end.",
          "example": "let arr = [1, 2, 3]; \nconsole.log(arr.at(-1)); \n// 3"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.forEach()` method always returns a new array with the results of the callback function.",
          "answer": false,
          "explanation": "`.forEach()` executes a callback for each element and returns `undefined`, not a new array.",
          "example": "let arr = [1, 2]; \nconsole.log(arr.forEach(x => x * 2)); \n// undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.unshift()` method adds elements to the beginning of an array and returns the new length.",
          "answer": true,
          "explanation": "`.unshift()` adds elements to the start of an array and returns the new `.length` of the array.",
          "example": "let arr = [1, 2]; \nconsole.log(arr.unshift(0)); \n// 3"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.shift()` method removes the last element of an array.",
          "answer": false,
          "explanation": "`.shift()` removes the first element of an array, not the last (which is done by `.pop()`).",
          "example": "let arr = [1, 2, 3]; \nconsole.log(arr.shift()); \n// 1"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the result of `let arr = [1, 2, 3]; \nconsole.log(arr.unshift(0));`?",
          "options": {
            "1": "[0, 1, 2, 3]",
            "2": "4",
            "3": "[1, 2, 3, 0]",
            "4": "0"
          },
          "answer": "2",
          "explanation": "`.unshift(0)` adds 0 to the beginning of the array and returns the new length, which is 4.",
          "example": "let arr = [1, 2, 3]; \nconsole.log(arr.unshift(0)); \nconsole.log(arr); \n// 4 [0, 1, 2, 3]"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What does `let arr = [1, 2, 3]; \nconsole.log(arr.shift());` return?",
          "options": {
            "1": "1",
            "2": "3",
            "3": "[2, 3]",
            "4": "undefined"
          },
          "answer": "1",
          "explanation": "`.shift()` removes and returns the first element of the array, which is 1.",
          "example": "let arr = [1, 2, 3]; \nconsole.log(arr.shift()); \nconsole.log(arr); \n// 1 [2, 3]"
        }
      ]
    },
    {
      "type": 2,
      "level": "medium",
      "question": [
        {
          "question": "What is the result of `let arr = [1, 2, 3, 4]; \nconsole.log(arr.slice(-2));`?",
          "options": {
            "1": "[1, 2]",
            "2": "[3, 4]",
            "3": "[2, 3]",
            "4": "[4]"
          },
          "answer": "2",
          "explanation": "`.slice(-2)` extracts the last two elements of the array, returning `[3, 4]`.",
          "example": "let arr = [1, 2, 3, 4]; \nconsole.log(arr.slice(-2)); \n// [3, 4]"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The result of `0.1 + 0.2` in JavaScript is exactly `0.3`.",
          "answer": false,
          "explanation": "Due to floating-point precision issues in JavaScript, `0.1 + 0.2` results in `0.30000000000000004`, not exactly `0.3`.",
          "example": "console.log(0.1 + 0.2); \n// 0.30000000000000004"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "`Number.isNaN('42')` returns `true`.",
          "answer": false,
          "explanation": "`Number.isNaN()` only returns `true` for the `NaN` value; \n`'42'` is a string and returns `false`.",
          "example": "console.log(Number.isNaN('42')); \n// false"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Numbers beyond `Number.MAX_SAFE_INTEGER` may lose precision in JavaScript.",
          "answer": true,
          "explanation": "Numbers larger than `Number.MAX_SAFE_INTEGER` (2^53 - 1) may lose precision due to JavaScript's 64-bit floating-point representation.",
          "example": "console.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2); \n// true (loss of precision)"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Performing arithmetic with `undefined` results in `0`.",
          "answer": false,
          "explanation": "Arithmetic operations with `undefined` coerce it to `NaN`, resulting in `NaN`, not `0`.",
          "example": "console.log(undefined + 1); \n// NaN"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.toFixed()` method returns a number, not a string.",
          "answer": false,
          "explanation": "`.toFixed()` returns a string representing the number with a specified number of decimal places.",
          "example": "let num = 3.14159; \nconsole.log(num.toFixed(2)); \nconsole.log(typeof num.toFixed(2)); \n// '3.14' 'string'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The expression true && false evaluates to true.",
          "answer": false,
          "explanation": "The `&&` operator returns `false` if any operand is `false`, so `true && false` is `false`.",
          "example": "console.log(true && false); \n// false"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "An empty string ('') is considered a truthy value.",
          "answer": false,
          "explanation": "An empty string is a falsy value in JavaScript, evaluating to `false` in a boolean context.",
          "example": "console.log(Boolean('')); \n// false"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The Boolean() function and !! operator always produce the same result when converting a value.",
          "answer": true,
          "explanation": "Both `Boolean()` and the double NOT operator (`!!`) convert a value to a boolean, producing identical results.",
          "example": "let val = 'hello'; \nconsole.log(Boolean(val), !!val); \n// true true"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The value null is considered falsy in a Boolean context.",
          "answer": true,
          "explanation": "`null` is a falsy value, evaluating to `false` in a boolean context.",
          "example": "console.log(Boolean(null)); \n// false"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Using new Boolean(false) creates a primitive Boolean value.",
          "answer": false,
          "explanation": "`new Boolean(false)` creates a Boolean object, not a primitive boolean value.",
          "example": "let bool = new Boolean(false); \nconsole.log(typeof bool); \n// 'object'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "When concatenating strings, the original string is modified directly in memory.",
          "answer": false,
          "explanation": "Strings are immutable, so concatenation creates a new string without modifying the original.",
          "example": "let str = 'hello'; \nlet newStr = str + ' world'; \nconsole.log(str); \n// 'hello'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.charAt(0)` method returns the same result as using the index `string[0]`.",
          "answer": true,
          "explanation": "Both `.charAt(0)` and `string[0]` return the character at index 0, though `.charAt()` handles out-of-bounds differently.",
          "example": "let str = 'hello'; \nconsole.log(str.charAt(0), str[0]); \n// 'h' 'h'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "Accessing a string with a negative index using `string[-1]` returns a valid character.",
          "answer": false,
          "explanation": "JavaScript strings do not support negative indexing with bracket notation; \nit returns `undefined`.",
          "example": "let str = 'hello'; \nconsole.log(str[-1]); \n// undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.slice()` method can accept negative indices to count from the end of the string.",
          "answer": true,
          "explanation": "`.slice()` supports negative indices, counting from the end of the string to extract a substring.",
          "example": "let str = 'hello'; \nconsole.log(str.slice(-2)); \n// 'lo'"
        }
      ]
    },
    {
      "type": 1,
      "level": "medium",
      "question": [
        {
          "question": "The `.substring()` method treats negative indices as 0.",
          "answer": true,
          "explanation": "`.substring()` converts negative indices to 0, treating them as the start of the string.",
          "example": "let str = 'hello'; \nconsole.log(str.substring(-1, 2)); \n// 'he'"
        }
      ]
    }
  ],
  "3": [
      {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let arr = [1, 2, 3]; console.log(arr.push(4, 5));`?",
          "options": {
            "1": "[1, 2, 3, 4, 5]",
            "2": "5",
            "3": "[4, 5]",
            "4": "2"
          },
          "answer": "2"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let arr = [1, 2, 3, 4]; console.log(arr.pop());` return?",
          "options": {
            "1": "1",
            "2": "4",
            "3": "[1, 2, 3]",
            "4": "undefined"
          },
          "answer": "2"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let arr = [1, 2, 3, 4]; console.log(arr.slice(1, 3));`?",
          "options": {
            "1": "[1, 2]",
            "2": "[2, 3]",
            "3": "[2, 3, 4]",
            "4": "[1, 2, 3]"
          },
          "answer": "2"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What happens when you execute `let arr = [1, 2, 3]; console.log(arr.splice(1, 1, 'a'));`?",
          "options": {
            "1": "['a']",
            "2": "[2]",
            "3": "[1, 'a', 3]",
            "4": "[1, 2, 3]"
          },
          "answer": "2"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let arr = [1, 2, 3]; console.log(arr.map(x => x * 2));` return?",
          "options": {
            "1": "[2, 4, 6]",
            "2": "[1, 2, 3]",
            "3": "undefined",
            "4": "[1, 4, 9]"
          },
          "answer": "1"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "Modifying an array declared with `const` will throw an error because the array is immutable.",
          "answer": false
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "Sparse arrays in JavaScript do not allocate memory for undefined indices.",
          "answer": true
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let arr = [1, 2, 3]; console.log(arr.filter(x => x > 1));`?",
          "options": {
            "1": "[1]",
            "2": "[2, 3]",
            "3": "[1, 2, 3]",
            "4": "[]"
          },
          "answer": "2"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let arr = [1, 2, 3]; console.log(arr.reduce((acc, x) => acc + x, 0));` return?",
          "options": {
            "1": "6",
            "2": "1",
            "3": "[1, 2, 3]",
            "4": "undefined"
          },
          "answer": "1"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let arr = [5, 10, 15]; console.log(arr.find(x => x > 10));`?",
          "options": {
            "1": "5",
            "2": "10",
            "3": "15",
            "4": "undefined"
          },
          "answer": "3"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let arr = [1, 2, 3]; console.log(arr.some(x => x > 2));` return?",
          "options": {
            "1": "true",
            "2": "false",
            "3": "[3]",
            "4": "undefined"
          },
          "answer": "1"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "The `.forEach()` method can modify the original array if the callback function alters its elements.",
          "answer": true
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let arr = [1, 2, 3]; let copy = arr; copy[0] = 10; console.log(arr);`?",
          "options": {
            "1": "[1, 2, 3]",
            "2": "[10, 2, 3]",
            "3": "[]",
            "4": "undefined"
          },
          "answer": "2"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let arr = [[1, 2], [3, 4]]; console.log(arr[1][0]);` return?",
          "options": {
            "1": "1",
            "2": "2",
            "3": "3",
            "4": "4"
          },
          "answer": "3"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let arr = []; arr[5] = 'x'; console.log(arr.length);`?",
          "options": {
            "1": "0",
            "2": "1",
            "3": "5",
            "4": "6"
          },
          "answer": "4"
        }
      ]
    },
     {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Modifying a property on an object created with `Object.create()` can affect the prototype if the property is not shadowed.",
        "answer": true,
        "explanation": "If a property is not defined as an own property on the object, modifying it updates the prototype’s property, as it’s accessed via the prototype chain.",
        "example": "let proto = { name: 'Luiz' }; let obj = Object.create(proto); proto.name = 'Marta'; console.log(obj.name); \n// 'Marta'"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Factory Functions create a new copy of methods for each object, leading to higher memory usage compared to Class Syntax.",
        "answer": true,
        "explanation": "Factory Functions duplicate methods for each object, while Class Syntax shares methods via the prototype, optimizing memory.",
        "example": "function createObj() { return { greet: () => 'Hi' }; } let obj1 = createObj(); let obj2 = createObj(); console.log(obj1.greet === obj2.greet); \n// false"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A class constructor that omits `super()` in a subclass causes a `ReferenceError` if `this` is used before calling `super`.",
        "answer": true,
        "explanation": "In a subclass, `this` cannot be accessed before calling `super()`, as the parent class must initialize the instance first.",
        "example": "class Parent {} class Child extends Parent { constructor() { this.name = 'Luiz'; } } let c = new Child(); \n// ReferenceError"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`Object.create()` with a non-enumerable prototype property prevents that property from appearing in `for...in` loops on the derived object.",
        "answer": true,
        "explanation": "Non-enumerable properties in the prototype are not iterated over in `for...in` loops, even if accessible via the prototype chain.",
        "example": "let proto = Object.defineProperty({}, 'name', { value: 'Luiz', enumerable: false }); let obj = Object.create(proto); for (let key in obj) { console.log(key); } \n// no output"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Using `Object.defineProperty()` on a `new Object()` instance can make a property non-writable, preventing future modifications.",
        "answer": true,
        "explanation": "`Object.defineProperty()` can set `writable: false`, making a property immutable unless reconfigured with `configurable: true`.",
        "example": "let obj = new Object(); Object.defineProperty(obj, 'name', { value: 'Luiz', writable: false }); obj.name = 'Marta'; console.log(obj.name); \n// 'Luiz'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `function Person(name) { this.name = name; } Person.prototype.greet = function() { return 'Hi'; }; let p = new Person('Luiz'); delete p.greet; console.log(p.greet());`?",
        "options": {
          "1": "'Hi'",
          "2": "undefined",
          "3": "null",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Deleting `p.greet` removes any own `greet` property, but the prototype’s `greet` method is still accessible via the prototype chain.",
        "example": "function Person(name) { this.name = name; } Person.prototype.greet = function() { return 'Hi'; }; let p = new Person('Luiz'); delete p.greet; console.log(p.greet()); \n// 'Hi'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let proto = { name: 'Luiz' }; let obj = Object.create(proto); Object.defineProperty(obj, 'name', { value: 'Marta', writable: false }); obj.name = 'John'; console.log(obj.name);` return?",
        "options": {
          "1": "'Luiz'",
          "2": "'Marta'",
          "3": "'John'",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "Defining `name` as non-writable on `obj` creates an own property, shadowing the prototype’s `name`. The assignment `obj.name = 'John'` has no effect.",
        "example": "let proto = { name: 'Luiz' }; let obj = Object.create(proto); Object.defineProperty(obj, 'name', { value: 'Marta', writable: false }); obj.name = 'John'; console.log(obj.name); \n// 'Marta'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `class Parent { constructor() { this.name = 'Luiz'; } } class Child extends Parent { constructor() { super(); this.name = 'Marta'; } } let c = new Child(); console.log(c.name, Object.getPrototypeOf(c).name);`?",
        "options": {
          "1": "'Marta', undefined",
          "2": "'Marta', 'Luiz'",
          "3": "'Luiz', 'Marta'",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `Child` constructor sets `name` to 'Marta' after calling `super()`. The prototype (Parent instance) has no own `name` property, so it’s `undefined`.",
        "example": "class Parent { constructor() { this.name = 'Luiz'; } } class Child extends Parent { constructor() { super(); this.name = 'Marta'; } } let c = new Child(); console.log(c.name, Object.getPrototypeOf(c).name); \n// 'Marta', undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `function createObj() { let secret = 'hidden'; return { getSecret: () => secret }; } let obj1 = createObj(); let obj2 = createObj(); secret = 'changed'; console.log(obj1.getSecret());` return?",
        "options": {
          "1": "'hidden'",
          "2": "'changed'",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `secret` variable is private to each `createObj` call via closure. Changing `secret` outside does not affect the closure’s value.",
        "example": "function createObj() { let secret = 'hidden'; return { getSecret: () => secret }; } let obj1 = createObj(); let obj2 = createObj(); secret = 'changed'; console.log(obj1.getSecret()); \n// 'hidden'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let obj = Object.create(null); obj[Symbol('id')] = 1; console.log(Object.getOwnPropertySymbols(obj).length);`?",
        "options": {
          "1": "0",
          "2": "1",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "Assigning a `Symbol` property to `obj` creates an own property. `Object.getOwnPropertySymbols()` returns an array with one symbol, so the length is 1.",
        "example": "let obj = Object.create(null); obj[Symbol('id')] = 1; console.log(Object.getOwnPropertySymbols(obj).length); \n// 1"
      }
    ]
  },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: 1 }; \nObject.assign(obj, { b: 2 }); \nconsole.log(obj);`?",
          "options": {
            "1": "{ a: 1 }",
            "2": "{ b: 2 }",
            "3": "{ a: 1, b: 2 }",
            "4": "{}"
          },
          "answer": "3",
          "explanation": "`Object.assign()` merges properties from the source object into the target, modifying the target to include both `a` and `b`.",
          "example": "let obj = { a: 1 }; \nObject.assign(obj, { b: 2 }); \nconsole.log(obj); \n// { a: 1, b: 2 }"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let obj = { a: 1 }; \nObject.freeze(obj); \nobj.a = 2; \nconsole.log(obj.a);` return?",
          "options": {
            "1": "1",
            "2": "2",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "`Object.freeze()` makes the object immutable, preventing modifications to existing properties, so `obj.a` remains 1.",
          "example": "let obj = { a: 1 }; \nObject.freeze(obj); \nobj.a = 2; \nconsole.log(obj.a); \n// 1"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: 1 }; \nObject.seal(obj); \nobj.a = 2; \nconsole.log(obj);`?",
          "options": {
            "1": "{ a: 1 }",
            "2": "{ a: 2 }",
            "3": "{}",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "`Object.seal()` allows modifying existing properties but prevents adding or deleting properties, so `obj.a` is updated to 2.",
          "example": "let obj = { a: 1 }; \nObject.seal(obj); \nobj.a = 2; \nconsole.log(obj); \n// { a: 2 }"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let proto = { a: 1 }; \nlet obj = Object.create(proto); \nconsole.log(obj.hasOwnProperty('a'));` return?",
          "options": {
            "1": "true",
            "2": "false",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "`hasOwnProperty()` checks for own properties, not inherited ones. Since `a` is on the prototype, it returns `false`.",
          "example": "let proto = { a: 1 }; \nlet obj = Object.create(proto); \nconsole.log(obj.hasOwnProperty('a')); \n// false"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: 1, b: { c: 2 } }; \nlet copy = JSON.parse(JSON.stringify(obj)); \ncopy.b.c = 3; \nconsole.log(obj.b.c);`?",
          "options": {
            "1": "2",
            "2": "3",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "`JSON.parse(JSON.stringify())` creates a deep copy, so modifying `copy.b.c` does not affect `obj.b.c`.",
          "example": "let obj = { a: 1, b: { c: 2 } }; \nlet copy = JSON.parse(JSON.stringify(obj)); \ncopy.b.c = 3; \nconsole.log(obj.b.c); \n// 2"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "The `JSON.parse(JSON.stringify())` method can copy methods of an object.",
          "answer": false,
          "explanation": "`JSON.stringify()` does not serialize functions, so methods are excluded in the deep copy created by `JSON.parse(JSON.stringify())`.",
          "example": "let obj = { a: 1, f: () => 'hi' }; \nlet copy = JSON.parse(JSON.stringify(obj)); \nconsole.log(copy.f); \n// undefined"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "The `Object.getOwnPropertyNames()` method returns both enumerable and non-enumerable own properties.",
          "answer": true,
          "explanation": "`Object.getOwnPropertyNames()` returns all own property names, including non-enumerable ones, unlike `Object.keys()`.",
          "example": "let obj = { a: 1 }; \nObject.defineProperty(obj, 'b', { value: 2, enumerable: false }); \nconsole.log(Object.getOwnPropertyNames(obj)); \n// ['a', 'b']"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: 1 }; \nObject.defineProperty(obj, 'b', { value: 2, enumerable: false }); \nconsole.log(Object.keys(obj));`?",
          "options": {
            "1": "['a', 'b']",
            "2": "['a']",
            "3": "['b']",
            "4": "[]"
          },
          "answer": "2",
          "explanation": "`Object.keys()` returns only enumerable own properties, so `b` (non-enumerable) is excluded.",
          "example": "let obj = { a: 1 }; \nObject.defineProperty(obj, 'b', { value: 2, enumerable: false }); \nconsole.log(Object.keys(obj)); \n// ['a']"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let entries = [['x', 10], ['y', 20]]; \nconsole.log(Object.fromEntries(entries));` return?",
          "options": {
            "1": "{ x: 10, y: 20 }",
            "2": "[['x', 10], ['y', 20]]",
            "3": "{ 10: 'x', 20: 'y' }",
            "4": "undefined"
          },
          "answer": "1",
          "explanation": "`Object.fromEntries()` transforms an array of key-value pairs into an object, creating `{ x: 10, y: 20 }`.",
          "example": "let entries = [['x', 10], ['y', 20]]; \nconsole.log(Object.fromEntries(entries)); \n// { x: 10, y: 20 }"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let objA = { a: 1 }; \nlet objB = objA; \nobjB.a = 2; \nconsole.log(objA.a);`?",
          "options": {
            "1": "1",
            "2": "2",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "Since `objB` is a reference to `objA`, modifying `objB.a` changes `objA.a` as they point to the same object.",
          "example": "let objA = { a: 1 }; \nlet objB = objA; \nobjB.a = 2; \nconsole.log(objA.a); \n// 2"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let obj = { a: 1, b: 2 }; \nconsole.log(Object.entries(obj));` return?",
          "options": {
            "1": "[['a', 1], ['b', 2]]",
            "2": "['a', 'b']",
            "3": "[1, 2]",
            "4": "{ a: 1, b: 2 }"
          },
          "answer": "1",
          "explanation": "`Object.entries()` returns an array of arrays, each containing a key-value pair of the object's enumerable properties.",
          "example": "let obj = { a: 1, b: 2 }; \nconsole.log(Object.entries(obj)); \n// [['a', 1], ['b', 2]]"
        }
      ]
    },
    {
      "type": 1,
      "level": "hard",
      "question": [
        {
          "question": "The `Object.defineProperty()` method can make a property non-writable.",
          "answer": true,
          "explanation": "`Object.defineProperty()` can set a property's `writable` attribute to `false`, preventing value changes.",
          "example": "let obj = {}; \nObject.defineProperty(obj, 'a', { value: 1, writable: false }); \nobj.a = 2; \nconsole.log(obj.a); \n// 1"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: NaN }; \nconsole.log(Object.is(obj.a, NaN));`?",
          "options": {
            "1": "true",
            "2": "false",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "`Object.is()` performs strict equality, correctly identifying `NaN` as equal to itself, unlike `===`.",
          "example": "let obj = { a: NaN }; \nconsole.log(Object.is(obj.a, NaN)); \n// true"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What does `let obj = { name: 'Luiz', details: { age: 29 } }; \nlet copy = { ...obj }; \ncopy.details.age = 30; \nconsole.log(obj.details.age);` return?",
          "options": {
            "1": "29",
            "2": "30",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "2",
          "explanation": "The spread operator creates a shallow copy, so `details` is still a reference to the same nested object, and modifying `copy.details.age` affects `obj.details.age`.",
          "example": "let obj = { name: 'Luiz', details: { age: 29 } }; \nlet copy = { ...obj }; \ncopy.details.age = 30; \nconsole.log(obj.details.age); \n// 30"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `console.log(Number.isSafeInteger(9007199254740992));`?",
          "options": {
            "1": "true",
            "2": "false",
            "3": "undefined",
            "4": "NaN"
          },
          "answer": "2",
          "explanation": "`Number.isSafeInteger()` returns `false` for numbers beyond `Number.MAX_SAFE_INTEGER` (2^53 - 1), as 9007199254740992 exceeds this limit and may lose precision.",
          "example": "console.log(Number.isSafeInteger(9007199254740992)); \n// false"
        }
      ]
    },
    {
      "type": 2,
      "level": "hard",
      "question": [
        {
          "question": "What is the result of `let obj = { a: null }; \nconsole.log(obj.a === null);`?",
          "options": {
            "1": "true",
            "2": "false",
            "3": "undefined",
            "4": "Error"
          },
          "answer": "1",
          "explanation": "The `===` operator checks for strict equality in both value and type. Since `obj.a` is explicitly `null`, `obj.a === null` returns `true`.",
          "example": "let obj = { a: null }; \nconsole.log(obj.a === null); \n// true"
        }
      ]
    },
     {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "A `let` variable declared in a `for` loop creates a new binding for each iteration, preventing closure issues with asynchronous code.",
        "answer": true,
        "explanation": "Each iteration of a `for` loop with `let` creates a new block-scoped binding, ensuring that asynchronous callbacks capture the correct value for each iteration, unlike `var`.",
        "example": "for (let i = 0; i < 3; i++) { setTimeout(() => console.log(i), 0); } // 0, 1, 2"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Redeclaring a `const` variable in a nested block scope does not throw a syntax error.",
        "answer": true,
        "explanation": "A `const` variable can be redeclared in a nested block scope because it creates a new binding in a different scope, adhering to block scoping rules.",
        "example": "const x = 1; { const x = 2; console.log(x); } console.log(x); \n// 2, 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `String.prototype.slice()` method handles negative indices differently than `substring()`, counting from the end of the string.",
        "answer": true,
        "explanation": "`slice()` interprets negative indices as counting from the string's end, while `substring()` treats them as 0, leading to different substring extractions.",
        "example": "let str = 'hello'; console.log(str.slice(-2), str.substring(-2)); \n// 'lo', 'hello'"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`Object.defineProperties()` can define non-enumerable properties, excluding them from `for...in` loops.",
        "answer": true,
        "explanation": "`Object.defineProperties()` allows setting `enumerable: false`, preventing properties from appearing in `for...in` loops while remaining accessible.",
        "example": "let obj = {}; Object.defineProperties(obj, { a: { value: 1, enumerable: false } }); for (let key in obj) { console.log(key); } // no output"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Calling `.toPrecision()` with an argument less than 1 or greater than 100 throws a `RangeError`.",
        "answer": true,
        "explanation": "The `.toPrecision()` method requires its precision argument to be between 1 and 100; values outside this range cause a `RangeError`.",
        "example": "let num = 123.456; console.log(num.toPrecision(101)); \n// RangeError"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Converting a string to a boolean with `Boolean()` treats an empty string as falsy and a whitespace string as truthy.",
        "answer": true,
        "explanation": "An empty string (`''`) is falsy, while any non-empty string, including whitespace (`' '`), is truthy when converted with `Boolean()`.",
        "example": "console.log(Boolean(''), Boolean(' ')); \n// false, true"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Calling `.reduce()` on an empty array without an initial value throws a `TypeError`.",
        "answer": true,
        "explanation": "Without an initial value, `.reduce()` expects at least one element; an empty array causes a `TypeError` as there's no accumulator to start with.",
        "example": "let arr = []; arr.reduce((acc, val) => acc + val); \n// TypeError"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `String.prototype.normalize()` method can change a string’s length when converting between Unicode normalization forms.",
        "answer": true,
        "explanation": "`.normalize()` can combine or decompose Unicode characters (e.g., NFC vs. NFD), altering the string’s length based on the normalization form.",
        "example": "let str = 'é'; console.log(str.normalize('NFC').length, str.normalize('NFD').length); \n// 1, 2"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Properties inherited via `Object.create()` are included in `for...in` loops if they are enumerable in the prototype.",
        "answer": true,
        "explanation": "Enumerable properties in the prototype chain are iterated over by `for...in`, as long as they are marked `enumerable: true`.",
        "example": "let proto = { a: 1 }; Object.defineProperty(proto, 'a', { enumerable: true }); let obj = Object.create(proto); for (let key in obj) { console.log(key); } // 'a'"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `.flatMap()` method is more efficient than chaining `.map()` and `.flat()` for deeply nested arrays.",
        "answer": true,
        "explanation": "`.flatMap()` combines mapping and flattening in one pass, reducing overhead compared to separate `.map()` and `.flat()` operations.",
        "example": "let arr = [1, 2]; console.log(arr.flatMap(x => [x, x * 2])); \n// [1, 2, 2, 4]"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `typeof` operator returns 'number' for both `NaN` and `Infinity`.",
        "answer": true,
        "explanation": "In JavaScript, `NaN` and `Infinity` are of type `number`, so `typeof NaN` and `typeof Infinity` return 'number'.",
        "example": "console.log(typeof NaN, typeof Infinity); \n// 'number', 'number'"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`Object.is()` distinguishes between `0` and `-0`, unlike the `===` operator.",
        "answer": true,
        "explanation": "`Object.is()` treats `0` and `-0` as distinct values, while `===` considers them equal due to JavaScript’s equality coercion.",
        "example": "console.log(Object.is(0, -0), 0 === -0); \n// false, true"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `String.prototype.match()` method returns `null` when no matches are found with a regular expression.",
        "answer": true,
        "explanation": "`.match()` returns `null` if the regular expression finds no matches, rather than an empty array.",
        "example": "let str = 'hello'; console.log(str.match(/x/)); \n// null"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "The `.splice()` method always returns an array, even if no elements are removed.",
        "answer": true,
        "explanation": "`.splice()` returns an array of removed elements, which is empty if no elements are removed, never returning `undefined`.",
        "example": "let arr = [1, 2]; console.log(arr.splice(1, 0, 'a')); \n// []"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "`Object.getOwnPropertySymbols()` retrieves `Symbol` properties directly defined on an object.",
        "answer": true,
        "explanation": "`Object.getOwnPropertySymbols()` returns an array of `Symbol` keys defined directly on the object, ignoring string-based properties.",
        "example": "let sym = Symbol('id'); let obj = { [sym]: 1 }; console.log(Object.getOwnPropertySymbols(obj).length); \n// 1"
      }
    ]
  },
  {
    "type": 1,
    "level": "hard",
    "question": [
      {
        "question": "Overriding `.toString()` on a `Number` object can cause `.toString()` to return unexpected results.",
        "answer": true,
        "explanation": "If `.toString()` is overridden on a `Number` object, it may not return the number’s string representation, leading to custom or unexpected output.",
        "example": "let num = new Number(42); num.toString = () => 'custom'; console.log(num.toString()); \n// 'custom'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let x; { let x = 1; { x = 2; } console.log(x); } console.log(x);`?",
        "options": {
          "1": "2, undefined",
          "2": "1, undefined",
          "3": "2, 1",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `let x` in the outer block creates a block-scoped variable. The assignment `x = 2` in the nested block modifies it. Outside, the global `x` is `undefined`.",
        "example": "let x; { let x = 1; { x = 2; } console.log(x); } console.log(x); \n// 2, undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let str = 'café'; console.log(str.normalize('NFD').length);` return?",
        "options": {
          "1": "4",
          "2": "5",
          "3": "6",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "The string 'café' has 4 characters, but NFD normalization decomposes 'é' into 'e' and an accent, resulting in 5 code units.",
        "example": "let str = 'café'; console.log(str.normalize('NFD').length); \n// 5"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let obj = Object.create({ a: 1 }, { b: { value: 2, writable: false } }); console.log(obj.b = 3, obj.b);`?",
        "options": {
          "1": "3, 2",
          "2": "2, 2",
          "3": "3, 3",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The property `b` is non-writable (`writable: false`). Assigning `obj.b = 3` returns 3 but doesn’t change `b`, which remains 2.",
        "example": "let obj = Object.create({ a: 1 }, { b: { value: 2, writable: false } }); console.log(obj.b = 3, obj.b); \n// 3, 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let num = 0.1 + 0.2; console.log(Math.fround(num) === 0.3);` return?",
        "options": {
          "1": "true",
          "2": "false",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "`Math.fround()` converts to 32-bit float, but `0.1 + 0.2` yields ~0.30000000000000004, which is not equal to 0.3.",
        "example": "let num = 0.1 + 0.2; console.log(Math.fround(num) === 0.3); \n// false"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2]; arr.length = 5; arr.fill(0, 2); console.log(arr);`?",
        "options": {
          "1": "[1, 2, 0, 0, 0]",
          "2": "[1, 2, undefined, undefined, undefined]",
          "3": "[1, 2, 0, undefined, undefined]",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Setting `arr.length = 5` creates empty slots. `.fill(0, 2)` fills indices 2 to 4 with 0, resulting in `[1, 2, 0, 0, 0]`.",
        "example": "let arr = [1, 2]; arr.length = 5; arr.fill(0, 2); console.log(arr); \n// [1, 2, 0, 0, 0]"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let str = 'hello'; console.log(str.match(/(l+)/g));` return?",
        "options": {
          "1": "['ll']",
          "2": "['l', 'l']",
          "3": "null",
          "4": "['ll', 'l']"
        },
        "answer": "1",
        "explanation": "The regex `(l+)/g` captures sequences of one or more 'l's. In 'hello', it matches 'll', returning `['ll']`.",
        "example": "let str = 'hello'; console.log(str.match(/(l+)/g)); \n// ['ll']"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2, 3]; let result = arr.reduceRight((acc, num) => acc + num, ''); console.log(result);`?",
        "options": {
          "1": "'321'",
          "2": "'123'",
          "3": "6",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.reduceRight()` processes from right to left, concatenating numbers to the initial string `''`, resulting in '3' + '2' + '1' = '321'.",
        "example": "let arr = [1, 2, 3]; let result = arr.reduceRight((acc, num) => acc + num, ''); console.log(result); \n// '321'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let obj = Object.create(null); Object.defineProperty(obj, Symbol('id'), { value: 1 }); console.log(Object.getOwnPropertySymbols(obj).length);` return?",
        "options": {
          "1": "0",
          "2": "1",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "`Object.defineProperty()` adds a `Symbol('id')` property. `Object.getOwnPropertySymbols()` returns an array with that symbol, so the length is 1.",
        "example": "let obj = Object.create(null); Object.defineProperty(obj, Symbol('id'), { value: 1 }); console.log(Object.getOwnPropertySymbols(obj).length); \n// 1"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2]; arr[3] = 4; console.log(arr.reduce((acc, num) => acc + num, 0));`?",
        "options": {
          "1": "7",
          "2": "3",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Assigning `arr[3] = 4` creates a sparse array `[1, 2, undefined, 4]`. `.reduce()` skips empty slots, summing 1 + 2 + 4 = 7.",
        "example": "let arr = [1, 2]; arr[3] = 4; console.log(arr.reduce((acc, num) => acc + num, 0)); \n// 7"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let str = 'hello'; console.log(str.replaceAll('l', () => 'p'));` return?",
        "options": {
          "1": "'heppo'",
          "2": "'helpo'",
          "3": "'heppop'",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.replaceAll()` replaces all 'l's with the result of the function, which returns 'p', yielding 'heppo'.",
        "example": "let str = 'hello'; console.log(str.replaceAll('l', () => 'p')); \n// 'heppo'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let num = 1e308; console.log(num * 2);`?",
        "options": {
          "1": "Infinity",
          "2": "2e308",
          "3": "NaN",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "Multiplying `1e308` by 2 exceeds `Number.MAX_VALUE` (~1.797e308), resulting in `Infinity`.",
        "example": "let num = 1e308; console.log(num * 2); \n// Infinity"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, [2, [3]]]; console.log(arr.flat(Infinity).length);` return?",
        "options": {
          "1": "3",
          "2": "2",
          "3": "4",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.flat(Infinity)` flattens all nested arrays, resulting in `[1, 2, 3]`, with a length of 3.",
        "example": "let arr = [1, [2, [3]]]; console.log(arr.flat(Infinity).length); \n// 3"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let obj = { a: 1 }; Object.defineProperty(obj, 'a', { value: 2, configurable: false }); delete obj.a; console.log(obj.a);`?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "2",
        "explanation": "Setting `configurable: false` prevents deletion of `a`. The value is updated to 2, and `delete` has no effect, so `obj.a` is 2.",
        "example": "let obj = { a: 1 }; Object.defineProperty(obj, 'a', { value: 2, configurable: false }); delete obj.a; console.log(obj.a); \n// 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, 2, 3]; console.log(arr.copyWithin(1, 0, 2));` return?",
        "options": {
          "1": "[1, 1, 2]",
          "2": "[1, 2, 3]",
          "3": "[1, 1, 3]",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.copyWithin(1, 0, 2)` copies elements from indices 0 to 1 to start at index 1, resulting in `[1, 1, 2]`.",
        "example": "let arr = [1, 2, 3]; console.log(arr.copyWithin(1, 0, 2)); \n// [1, 1, 2]"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let str = 'hello'; console.log(str.codePointAt(0));` return?",
        "options": {
          "1": "104",
          "2": "72",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.codePointAt(0)` returns the Unicode code point of 'h', which is 104.",
        "example": "let str = 'hello'; console.log(str.codePointAt(0)); \n// 104"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, 2, 3]; console.log(arr.findLast(num => num < 3));` return?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "3",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "`.findLast()` returns the last element satisfying `< 3`, which is 2, iterating from right to left.",
        "example": "let arr = [1, 2, 3]; console.log(arr.findLast(num => num < 3)); \n// 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let num = 123.456; console.log(Number.parseFloat(num.toFixed(2)));`?",
        "options": {
          "1": "123.46",
          "2": "123.45",
          "3": "123.456",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.toFixed(2)` rounds to '123.46' as a string. `Number.parseFloat()` converts it back to the number 123.46.",
        "example": "let num = 123.456; console.log(Number.parseFloat(num.toFixed(2))); \n// 123.46"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let obj = { [Symbol.toPrimitive]() { return 42; } }; console.log(+obj);` return?",
        "options": {
          "1": "42",
          "2": "NaN",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The `[Symbol.toPrimitive]` method defines the object’s primitive value, returning 42 when the unary `+` operator is applied.",
        "example": "let obj = { [Symbol.toPrimitive]() { return 42; } }; console.log(+obj); \n// 42"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2, 3]; arr[Symbol.iterator] = null; console.log([...arr]);`?",
        "options": {
          "1": "[1, 2, 3]",
          "2": "[]",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "4",
        "explanation": "Setting `arr[Symbol.iterator] = null` removes the array’s default iterator, causing a `TypeError` when the spread operator (`...`) is used.",
        "example": "let arr = [1, 2, 3]; arr[Symbol.iterator] = null; console.log([...arr]); \n// TypeError"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let str = 'hello'; console.log(str.replace(/(l)/g, '$1$1'));` return?",
        "options": {
          "1": "'heelloo'",
          "2": "'hhello'",
          "3": "'ll'",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "The regex `(l)/g` captures each 'l', and `$1$1` replaces each 'l' with two 'l's, resulting in 'heelloo'.",
        "example": "let str = 'hello'; console.log(str.replace(/(l)/g, '$1$1')); \n// 'heelloo'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let arr = [1, 2, 3]; console.log(arr.at(-2));`?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "3",
          "4": "undefined"
        },
        "answer": "2",
        "explanation": "The `.at(-2)` method accesses the element at index 1 (length - 2), returning 2.",
        "example": "let arr = [1, 2, 3]; console.log(arr.at(-2)); \n// 2"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let obj = { a: 1 }; Object.preventExtensions(obj); obj.b = 2; console.log(obj.b);` return?",
        "options": {
          "1": "1",
          "2": "2",
          "3": "undefined",
          "4": "Error"
        },
        "answer": "3",
        "explanation": "`Object.preventExtensions()` prevents adding new properties. Assigning `obj.b = 2` has no effect, and `obj.b` is `undefined`.",
        "example": "let obj = { a: 1 }; Object.preventExtensions(obj); obj.b = 2; console.log(obj.b); \n// undefined"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What is the output of `let num = 42; console.log(num.toLocaleString('en-US', { style: 'currency', currency: 'USD' }));`?",
        "options": {
          "1": "$42.00",
          "2": "42",
          "3": "USD 42",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.toLocaleString('en-US', { style: 'currency', currency: 'USD' })` formats the number as US currency, resulting in '$42.00'.",
        "example": "let num = 42; console.log(num.toLocaleString('en-US', { style: 'currency', currency: 'USD' })); \n// '$42.00'"
      }
    ]
  },
  {
    "type": 2,
    "level": "hard",
    "question": [
      {
        "question": "What does `let arr = [1, 2, 3]; console.log(arr.toSpliced(1, 1, 4));` return?",
        "options": {
          "1": "[1, 4, 3]",
          "2": "[1, 2, 3]",
          "3": "[2]",
          "4": "Error"
        },
        "answer": "1",
        "explanation": "`.toSpliced(1, 1, 4)` is a non-mutating method that returns a new array with the element at index 1 replaced by 4, yielding `[1, 4, 3]`.",
        "example": "let arr = [1, 2, 3]; console.log(arr.toSpliced(1, 1, 4)); \n// [1, 4, 3]"
      }
    ]
  }
  ]
};

        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let userAnswers = [];

        function startQuiz() {
            const level = document.getElementById('level').value;
            if (!level) return;

            // Reset quiz state
            currentQuestions = [];
            currentQuestionIndex = 0;
            score = 0;
            userAnswers = [];
            document.getElementById('results').style.display = 'none';
            document.getElementById('restart-btn').style.display = 'none';
            document.getElementById('quiz-container').style.display = 'block';
            document.getElementById('feedback-result').textContent = '';
            document.getElementById('feedback-explanation').textContent = '';
            document.getElementById('feedback-example').textContent = '';
            document.getElementById('next-btn').style.display = 'none';

            // Collect and shuffle questions for selected level
            for (let key in quizData) {
                quizData[key].forEach(q => {
                    if (q.level === level) {
                        currentQuestions.push(q);
                    }
                });
            }

            // Shuffle questions to vary order
            currentQuestions = shuffleArray(currentQuestions);

            if (currentQuestions.length === 0) {
                alert('No questions available for this level.');
                document.getElementById('quiz-container').style.display = 'none';
                return;
            }

            displayQuestion();
        }

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function displayQuestion() {
            if (currentQuestionIndex >= currentQuestions.length) {
                showResults();
                return;
            }

            const questionData = currentQuestions[currentQuestionIndex].question[0];
            const questionElement = document.getElementById('question');
            const answersElement = document.getElementById('answers');
            const feedbackResult = document.getElementById('feedback-result');
            const feedbackExplanation = document.getElementById('feedback-explanation');
            const feedbackExample = document.getElementById('feedback-example');
            const nextButton = document.getElementById('next-btn');

            questionElement.textContent = `${currentQuestionIndex + 1}. ${questionData.question}`;
            answersElement.innerHTML = '';
            feedbackResult.textContent = '';
            feedbackExplanation.textContent = '';
            feedbackExample.textContent = '';
            nextButton.style.display = 'none';

            if (currentQuestions[currentQuestionIndex].type === 1) {
                // True/False question
                answersElement.innerHTML = `
                    <button class="true-false-btn true-btn" onclick="selectAnswer(true)">True</button>
                    <button class="true-false-btn false-btn" onclick="selectAnswer(false)">False</button>
                `;
            } else {
                // Multiple-choice question with randomized options
                const options = Object.entries(questionData.options);
                const shuffledOptions = shuffleArray([...options]);

                shuffledOptions.forEach(([key, value]) => {
                    answersElement.innerHTML += `
                        <div class="answer-option">
                            <input type="radio" name="answer" value="${key}" id="option${key}" onchange="selectAnswer(this.value)">
                            <label for="option${key}">${value}</label>
                        </div>
                    `;
                });
            }
        }

        function selectAnswer(answer) {
            const questionData = currentQuestions[currentQuestionIndex].question[0];
            const feedbackResult = document.getElementById('feedback-result');
            const feedbackExplanation = document.getElementById('feedback-explanation');
            const feedbackExample = document.getElementById('feedback-example');
            const nextButton = document.getElementById('next-btn');
            const trueBtn = document.querySelector('.true-btn');
            const falseBtn = document.querySelector('.false-btn');
            const radioButtons = document.querySelectorAll('input[name="answer"]');

            // Store user answer
            userAnswers[currentQuestionIndex] = answer;

            // Check if answer is correct
            const correctAnswer = questionData.answer;
            const isCorrect = answer == correctAnswer;// Use == to handle string vs boolean comparison
            if (isCorrect) {
                score++;
                feedbackResult.textContent = 'Correct!';
                feedbackResult.className = 'correct';
            } else {
                feedbackResult.textContent = `Incorrect! The correct answer is: ${
                    currentQuestions[currentQuestionIndex].type === 1 ? correctAnswer : questionData.options[correctAnswer]
                }`;
                feedbackResult.className = 'incorrect';
            }

            // Display explanation and example
            feedbackExplanation.textContent = `Explanation: ${questionData.explanation}`;
            feedbackExample.textContent = `Example: ${questionData.example}`;

            // Disable answer options to prevent multiple submissions
            if (trueBtn && falseBtn) {
                trueBtn.classList.add('disabled-btn');
                falseBtn.classList.add('disabled-btn');
                trueBtn.disabled = true;
                falseBtn.disabled = true;
            }
            radioButtons.forEach(radio => radio.disabled = true);

            // Show next button
            nextButton.style.display = 'block';
        }

        function nextQuestion() {
            currentQuestionIndex++;
            displayQuestion();
        }

        function showResults() {
            document.getElementById('quiz-container').style.display = 'none';
            const resultsElement = document.getElementById('results');
            resultsElement.style.display = 'block';
            document.getElementById('restart-btn').style.display = 'block';

            let resultHTML = `<h2>Results: ${score}/${currentQuestions.length}</h2>`;
            currentQuestions.forEach((q, index) => {
                const questionData = q.question[0];
                const userAnswer = userAnswers[index];
                const correctAnswer = questionData.answer;
                const isCorrect = userAnswer == correctAnswer;

                resultHTML += `
                    <p>
                        ${index + 1}. ${questionData.question}<br>
                        Your answer: <span class="${isCorrect ? 'correct' : 'incorrect'}">
                            ${q.type === 1 ? userAnswer : (userAnswer ? questionData.options[userAnswer] : 'No answer')}
                        </span><br>
                        Correct answer: <span class="correct">
                            ${q.type === 1 ? correctAnswer : questionData.options[correctAnswer]}
                        </span><br>
                        Explanation: ${questionData.explanation}<br>
                        Example: <span style="font-family: monospace;">${questionData.example}</span>
                    </p>
                `;
            });

            resultsElement.innerHTML = resultHTML;
        }

        function restartQuiz() {
            document.getElementById('level').value = '';
            document.getElementById('quiz-container').style.display = 'none';
            document.getElementById('results').style.display = 'none';
            document.getElementById('restart-btn').style.display = 'none';
            currentQuestions = [];
            currentQuestionIndex = 0;
            score = 0;
            userAnswers = [];
        }
    </script>
</body>
</html>